---
banner: "![[Аннотация 2024-09-22 182639.png]]"
banner_y: 0.192
---
Первые шаги
```
#include <iostream>
int main() {
    std::cout << "Come up and C++ me some time." << std::endl;
    return 0;
}
```
Программы на С++ конструируются из строительных блоков, называемых функциями. Обычно программа систематизируется в набор главных задач , для обработки которых проектируются отдельные функции.
Пример main.cpp содержит следующие элементы:
- комментарии, обозначаемые с помощью //; 
- директива препроцессора # include; 
- заголовок функции : int main ( ) ; 
- директива using namespace; 
- тело функции , ограниченное фигурными скобками { и } ; 
- операторы, которые используют объект С++ cout для отображения сообщения; 
- оператор возврата для прекращения выполнения функции mai n ( ) .

![[Pasted image 20250330190513.png]]
Функция в языке С++ активизируется, или вызывается, другой функцией, и заголовок функции описывает интерфейс между функцией и вызывающей ее функцией. Та часть, которая предшествует имени функции, называется возвращаемым типом функции; в ней описывается информационный поток, поступающий из функции обратно к функции, которая ее вызвала. Та часть, которая заключена в скобки после имени функции, называется спискам аргументов или списком параметров, в ней описывается информационный поток, который поступает из вызывающей функции к вызываемой функции.

## Препроцессор С++ и файл iostream

Если ваша программа предназначена для использования обычных средств ввода и вывода в С++:
```
#include <iostream>
using namespace std;
```
В языке С++, как и в С, используется препроцессор. Препроцессор - это программа, которая выполняет обработку файла исходного кода перед началом собственно компиляции. Для вызова препроцессора ничего особенного делать не нужно. Он запускается автоматически во время компиляции программы.
В листинге 2.1 использовалась директива # include:
```
#include <iostream>// директива препроцессора
```
Часть io в iostream означает input (ввод) - входные данные программы, и оtрut (вывод) - информация, передаваемая из программы. Схема ввода-вывода в С++ включает несколько определений, которые можно найти в файле iostream.

### Имена заголовочных файлов 
**Современные заголовочные файлы C++** — используются без `.h`, поддерживают пространства имен (например, `iostream`, `cmath`).
**Старые заголовочные файлы C** — используют расширение `.h` (например, `math.h`). Они по-прежнему могут применяться в C++.
**Преобразованные заголовочные файлы C** — представляют собой версии заголовочных файлов C, адаптированные для C++ (например, `math.h` → `cmath`). Они лишены `.h` и имеют префикс `c`.
Важное отличие чистых заголовочных файлов C++ (например, `iostream`) в том, что они работают с пространствами имен, что делает код более удобным и безопасным.

### Пространства имен
```
using namespace std;
```
Это называется директивой using. Поддержка пространства имен - это средство С++, предназначенное для упрощения разработки крупных программ и программ, в которых комбинируется существующий код от нескольких поставщиков, а также для помощи в организации таких программ. Одна из потенциальных проблем заключается в том, что вы можете работать с двумя готовыми продуктами, в каждом из которых присутствует, скажем, функция wanda ( ) . При использовании функции wanda ( ) компилятор не будет знать, какая конкретно версия этой функции имеется в виду. Средство пространств имен позволяет поставщику упаковать свой продукт в модуль, называемый пространством имен. Вы, в свою очередь, можете использовать название этого пространства имен для указания, продукт какого производителя вам необходим.

Таким образом, для различения версий функции в программе вы можете использовать пространства имен:
```
Microflop::wanda("godancing?"); // использует версию из
								// пространсва имен microflop
Piscine::wanda("а fish named Desire"); // использует версию из
										// пространтства имен Piscine
```

### Вывод в С++ с помощью cout
```
std::cout << "Come up and C++ me some time." << std::endl;
```
Часть, заключенная в двойные кавычки - это сообщение, которое необходимо вывести. В С++ любая последовательность символов, заключеНJIЫХ в двойные кавычки , называется символьной строкой, по-видимому, из-за того, что она состоит из множества символов, собранных в одну большую конструкцию. Запись << означает, что оператор отправляет строку в cout; символы указывают на направление передачи информации
Cout -  предопределенный объект, который знает о том, как отображать разнообразные элементы, включая строки, цифры и индивидуальные символы.
> [!NOTE]
> объект представляет собой экземпляр класса, а к.ласе определяет способ хранения и использования данных

Возможно, приступать к использованию объектов еще рано, потому что они еще подробно не рассматривались. На самом деле, в приведенном примере продемонстрирована одна из сильных сторон объектов. Для работы с объектом вы не обязаны знать его внутреннюю структуру. Все, что вам необходимо знать - это его *интерфейс*, т.е. способ его использования. Объект cout имеет простой интерфейс. Если string представляет строку, то для ее вывода на экран можно сделать следующее:
```
cout << string;
```
Посмотрим, как этот процесс можно описать с точки зрения концептуального представления С++. В этом представлении вывод рассматривается как поток, т.е. последовательность символов, передаваемых из программы. Этот поток представляет объект cout, свойства которого определены в файле iostream. Свойства объекта cout включают операцию вставки ( <<) , которая добавляет в поток данные, указанные в правой части.
```
    std::cout << "Come up and C++ me some time." << std::endl;
```
В выходной поток будет помещена строка "Come up and C++ me some time "
![[Pasted image 20250330192928.png]]
### Манипулятор endl
```
cout << endl;
```
Здесь endl - это специальное обозначение в С++, которое представляет важное понятие начала новой строки.

### Лексемы и пробельные символы в исходном коде
Лексемами называются неделимые элементы в строке кода, для разделения лексем друг от друга используется пробел, табуляция или возврат каретки, которые все вместе называются пробельные символами.

Далее показаны примеры того, где используются пробельные символы, а где их можно опустить
```
return0;    //НЕПРАВИПЬНО, должно быть return 0
return(0);  //ПРАВИПЬНО , пробельный символ опущен
return (0); //ПРАВИПЬНО , используется пробельный символ
intmain();  //НЕПРАВИПЬНО, пробельный символ опущен
int main(); //ПРАВИПЬНО , пробельный символ опущен в скобках
int main( ) //ПРАВИПЬНО , пробельный символ используется в скобках
```
![[Pasted image 20250330221044.png]]

## Стиль написания исходного кода С++

**Хотя С++ предоставляет большую свободу в форматировании кода, программы будут легче читаться, если вы будете следовать осмысленному стилю при их написании. Допустимый, но написанный беспорядочным образом код не принесет никакого удовольствия от работы.**

- Один оператор в одной строке.
- Открывающая и закрывающая фигурные скобки для функции , каждая из которых находится в своей строке. 
- Операторы в функции записаны с отступом от фигурных скобок. 
- Вокруг круглых скобок, связанных с именем функции , пробельные символы отсутствуют. 

## Операторы в языке С++
Программа, написанная на языке С++, представляет собой коллекцию функций, каждая из которых, в свою очередь, является коллекцией операторов. В С++ имеется несколько разновидностей операторов. Первый из них, *оператор* *объявления*, создает переменную. Второй, *оператор присваивания*, присваивает этой переменной определенное значение.
```
#include <iostream>
int main()
{
    using namespace std;
    int carrots;
    cin >> carrots;
    cout << "I have ";
    cout << carrots;
    cout << endl;
    carrots = carrots - 1;
    cout << "Crunch, crunch. Now I have " << carrots << " carrots." << endl;
    return 0;
}
```
### Операторы объявления и переменные
Компьютеры - это точные и организованные машины. Для того чтобы сохранить элемент информации в компьютере, вы должны идентифицировать как ячейку памяти, так и объем памяти, требуемый для хранения этой информации. В языке С++ проще всего это можно сделать с помощью оператора объявления, который идентифицирует тип памяти и предоставляет метку для ячейки.
Имеется следующий оператор объявления:
```
int carrots;
```
Этот оператор предоставляет два вида информации: необходимый тип хранения и метку, привязанную к этой ячейке. В частности, оператор объявляет, что программа требует объема памяти, достаточного для хранения целого числа, для которого в С++ используется метка int.
Второй выполненной задачей является именование ячейки памяти. В этом случае оператор объявления говорит, что с этого момента программа будет использовать имя carrots для обозначения значения, хранящегося в указанной ячейке памяти. carrots - это переменная, поскольку ее значение можно изменять

В общем случае, объявление указывает тип сохраняемых данных и имя программы, которая будет использовать данные, хранящиеся в этой переменной. В этой конкретной ситуации программа создает переменную по имени carrots, в которой хранится целое число.

Оператор объявления в программе называется оператором *определяющего объявления*, или кратко - *определением*. Его присутствие означает, что компилятор выделит пространство памяти для хранения значений переменной. В более сложных ситуациях можно применять *ссылочное объявление*. В этом случае компьютер будет использовать переменную, которая уже где-то определена. В общем случае объявление не должно быть определением.

## Операторы присваивания
Оператор присваивания присваивает значение ячейке памяти.
```
carrots = 25;
int steinway;
int baldwin;
int yamaha;
yamaha = baldwin = steinway = 88;
```
Операция присваивания выполняется поочередно, справа налево. Операция присваивания выполняется поочередно, справа налево. Сначала значение 88 присваивается переменной steinway, затем это же значение присваивается переменной baldwin и, наконец, переменной yamaha

Возможность изменения значения переменной:
```
carrots = carrots - 1;
```

### Другие операторы С++
Вводить значение во время выполнения. Для этого в ней используется объект cin - аналог cout, но предназначенный для ввода.

```
cout << "Write ur family: ";
```
## Использование cin
```
cin >> carrots;
```
Взглянув на него, вы наглядно видите информационный поток из объекта cin в переменную carrots. При выводе операция << вставляет символы в поток вывода. При вводе объект cin использует операцию >> для извлечения символов из потока ввода. Обычно в правой части операции указывается переменная, которой будут присваиваться извлеченные данные. (Символы << и >> были выбраны для визуальной подсказки направления потока информации.)
### Конкатенация с помощью cout
Еще одной новой возможностью является комбинирование четырех операторов вывода в одном:
```
cout << " Now you have " << carrots << " carrots . " << endl
```
Такая запись позволяет объединить вывод строки и вывод целого числа в одном операторе. В результате выполнения кода вывод будет таким же, как если бы использовалась следующая запись:
```
cout << " Now you have ";
cout << carrots;
cout << "carrots";
cout « endl;
```
При желании объединенную версию можно переписать так, чтобы растянуть один оператор на четыре строки:
```
cout << "Now you have"
	 << carrots 
	 << "carrots."
	 << endl ;
```
### cin и cout: признак класса
Класс - это тип данных, определяемый пользователем. Класс определяет, какие данные он может хранить и какие действия можно выполнять с ними. Он описывает форму данных и способы их использования, тогда как объект — это созданная по этому описанию сущность. Класс — это категория, а объект — конкретный представитель этой категории. В ООП класс в C++ соответствует объектному типу, а объект — экземпляру класса.

```
int carrots;
```
В этом объявлении создается конкретная переменная (carrots), обладающая свойствами типа int. Другими словами, переменная carrots может хранить целое число и может использоваться в различных целях, например, для вычитания или сложения чисел. 
Что же касается cout, то про него можно сказать, что это объект, созданный для представления свойств класса ostream. В определении класса ostream (также находящемся в файле iostream) описана разновидность данных объекта ostream, а также операции, которые можно выполнять над этими данными, такие как вставка числа или строки в поток вывода. Аналогично cin - это объект, созданный со свойствами класса istream, который тоже определен в iostream.

> [!NOTE] На заметку
> Класс описывает все свойства типа данных, включая действия, которые могут над ним выполняться , а объект является сущностью, созданной в соответствии с этим описанием.

Классы, такие как `ostream` и `istream`, не встроены в C++, а находятся в библиотеке классов и определены в файле `<iostream>`. Они описаны в стандарте языка, но не встроены в компилятор. Семейства `iostream` (ввод-вывод) и `fstream` (файловый ввод-вывод) входят в стандарт C++, а также существуют дополнительные библиотеки классов, одобренные ANSI/ISO.

В описании класса указываются все действия, которые мoryr быть выполнены над объектами этого класса. Для выполнения этих действий объекту отправляется сообщение. В C++ это можно сделать двумя способами:
1. Использования классов
2. Перегрузка операций, cin и cout, где оператор < определен для вывода данных.

```
cout << "I am not а crook ."
```
В этом случае в сообщении содержится аргумент, представляющий собой строку, которую необходимо отобразить.
![[Pasted image 20250403173524.png]]
## Функции
Функции в С++ можно разбить на две категории: функции, которые возвращают значения, и функции , значения не возвращающие. Для каждой разновидности функций можно найти примеры в стандартной библиотеке функций С++. Кроме того, можно создавать собственные функции обеих категорий.
### Использование функции, имеющей возвращаемое значение
Функция, имеющая возвращаемое значение, генерирует значение, которое можно присвоить переменной или применить в каком-нибудь выражении. Например, стандартная библиотека С/С++ содержит функцию sqrt ( ) , которая возвращает квадратный корень из числа. 
```
#include <iostream>
#include <cmath>
int main()
{
    float x;
    using namespace std;
    x = sqrt(6.25);
    cout << x;
    return 0;
}
```
Выражение sqrt(6.25) активизирует, или вызывает, функцию sqrt(). Выражение sqrt(6 .25) называется вызовом функции, активизируемая функция - вызываемой функцией, а функция, содержащая вызов функции - вызывающей функцией. Аргумент — это информация, передаваемая функции, а возвращаемое значение — это результат, который функция отправляет обратно после выполнения. Например, `sqrt()` вычисляет корень и возвращает его, заменяя вызов функции в выражении.
![[Pasted image 20250403174337.png]]
Значение в круглых скобках (в нашем случае - 6.2 5) - это информация, которая отправляется функции; говорят, что это значение передается функции. Значение, которое отсылается функции подобным образом, называется аргументом или параметром.
![[Pasted image 20250403174537.png]]
Перед использованием функции компилятор должен знать тип её аргументов и возвращаемого значения. Это позволяет правильно интерпретировать результат. В C++ такая информация задаётся с помощью **прототипа функции**. Прототип функции определяет её типы аргументов и возвращаемого значения, подобно объявлению переменной. Например, для `sqrt()`, которая принимает и возвращает `double`, прототип выглядит так:
```
double sqrt(double);
```
Первый тип double означает, что функция sqrt() возвращает значение типа double. Тип double в круглых скобках означает, что функция sqrt() требует аргумента типа douЬle. Таким образом, этот прототип описывает функцию sqrt () в точности так, как она используется в следующем фрагменте кода:
```
double x; // объявляет х как переменную типа double
x = sqrt(6.25); 
```

**Прототипом функции** в [языке Си](https://ru.wikipedia.org/wiki/%D0%AF%D0%B7%D1%8B%D0%BA_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F_%D0%A1%D0%B8 "Язык программирования Си") или [C++](https://ru.wikipedia.org/wiki/C%2B%2B "C++") называется [объявление](https://ru.wikipedia.org/wiki/%D0%9E%D0%B1%D1%8A%D1%8F%D0%B2%D0%BB%D0%B5%D0%BD%D0%B8%D0%B5_\(%D0%B8%D0%BD%D1%84%D0%BE%D1%80%D0%BC%D0%B0%D1%82%D0%B8%D0%BA%D0%B0\) "Объявление (информатика)") [функции](https://ru.wikipedia.org/wiki/%D0%A4%D1%83%D0%BD%D0%BA%D1%86%D0%B8%D1%8F_\(%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5\) "Функция (программирование)"), не содержащее тела функции, но указывающее имя функции, [арность](https://ru.wikipedia.org/wiki/%D0%90%D1%80%D0%BD%D0%BE%D1%81%D1%82%D1%8C "Арность"), [типы](https://ru.wikipedia.org/wiki/%D0%A2%D0%B8%D0%BF_%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D1%85 "Тип данных") аргументов и возвращаемый тип данных. В то время как определение функции описывает, что именно делает функция, прототип функции может восприниматься как описание её интерфейса.
В прототипе имена аргументов являются необязательными, тем не менее, необходимо указывать тип вместе со всеми модификаторами (например, указатель ли это или константный аргумент).
В качестве примера, рассмотрим следующий прототип функции:
```
int foo(int n);
```
Этот прототип объявляет функцию с именем «foo», которая принимает один аргумент «n» [целого типа](https://ru.wikipedia.org/wiki/%D0%A6%D0%B5%D0%BB%D0%BE%D0%B5_%D1%87%D0%B8%D1%81%D0%BB%D0%BE "Целое число") и возвращает целое число. Определение функции может располагаться где угодно в программе, но объявление требуется только в случае её использования.

**Второй вариант лучше, поскольку заголовочный файл всегда предпочтительнее самостоятельного ввода прототипа**

## Разновидности функций
Для некоторых функций требуется более одного элемента информации. Такие функции принимают несколько аргументов, разделенных запятыми. Например , математическая функция pow ( ) принимает два аргумента и возвращает значение, равное первому аргументу, возведенному в степень, указанную во втором аргументе:
```
answer = pow(5.0, 8.0);
```
Есть функции , которые вообще не принимают аргументов. Например, одна из библиотек С содержит функцию rand ( ) , не принимающую аргументов и возвращающую случайное целое число. Ее прототип выглядит так:
```
int rand(void);
```
Ключевое слово void явно указывает на то, что функция не принимает аргументов. Если опустить это слово и оставить скобки пустыми , С++ интерпретирует это как неявное объявление об отсутствии аргументов. Эту функцию можно использовать следующим образом:
```
myGuess = rand(); // Функция без аргументов
```
Существуют также функции , которые не имеют возвращаемого значения. Поскольку эта функция выводит значение на экран, а не передает его вызывающей программе , она не требует возвращаемого значения. Эта особенность функции указывается в прототипе с использованием ключевого слова void для возвращаемого типа
```
void bucks(double);
```
Поскольку функция bucks () не возвращает значения, ее нельзя применять в качестве части оператора присваивания или какого-то другого выражения. Вместо этого вы имеете дело с чистым оператором вызова функции:
```
bucks(1234.56);
```

```
#include <iostream>
#include <cmath>
  
using namespace std;
  
void bucks(int n)
{
    cout << "\nBucks called with: " << n << endl;
}
  
int main()
{
  
    bucks(23);
    return 0;
}
```
### Функции, определяемые пользователем
```
#include <iostream>
#include <cmath>

void simon(int);
using namespace std;

int main()
// прототип функции simon ( )
{
    simon(3); // вызов функции simon ()
    cout << " Pick an intege: ";
    int count;
    cin >> count;
    simon(count); // еще один вызов simon ()
    cout << "Done!" << endl;
    return 0;
}
void simon (int n)
{
//определение функции s imon ( )
cout << " Simon says touch your toes " << n << " times ." << endl ;
//функции void не требуют операторов return
}
```
## Форма функции
Сначала идет заголовок функции. Затем в фигурных скобках следует тело функции.
```
тип имя_функции(аргумент)
{
	...
}
```
![[Pasted image 20250408125851.png]]
## Заголовки функций
Всё легко и просто:
```
#include <iostream>
#include <cmath>
using namespace std;

void addition()
{
    double a, b;
    cout << "Enter two numbers to add: " << endl;
    cout << "Enter the first number: ";
    cin >> a;
    cout << "Enter the second number: ";
    cin >> b;
    cout << a << " + " << b << " = " << a + b << endl;
}
  
void subtraction()
{
    double a, b;
    cout << "Enter two numbers to add\n";
    cout << "Enter the first number: ";
    cin >> a;
    cout << "Enter the second number: ";
    cin >> b;
    cout << a << " - " << b << " = " << a - b << endl;
}
  
int main ()
{
    int operation;
    cout << "Hi, this program is a calculator.\n" ;
    cout << "1. Addition\n2. Subtraction\n";
    cout << "Select the operation from the menu: ";
    cin >> operation;
    if (operation == 1) {
        addition();
        cout << endl;
    } else if (operation == 2) {
        subtraction();
        cout << endl;
    } else {
        cout << "Invalid operation selected." << endl;
    }
  
    return 0;
}
```
## Использование определяемых пользователем функций, имеющих возвращаемое значение
```
#include <iostream>
using namespace std;
double weighttopounds (double);//11 прототип функции
  
int main ()
{
    int weight;
    cout << "Введит ваш вес в килограммах для перевода в фунты: ";
    cin >> weight;
    double pounds = weighttopounds(weight);
    cout << "Ваш вес " << weight << " кг," << " а в " "в фунтах: " << pounds << endl;
}
  
double weighttopounds (double sts)
{
    double pounds = 2.20462 * sts;
    return pounds;
}
```
В функции main ( ) программа использует объект cin для ввода значения вещественной переменной weight. Это значение передается функции weighttopounds() в качестве аргумента и присваивается переменной sts в этой функции. 
Функция weighttopounds() использует ключевое слово return для возврата значения 2.20462*sts().

Можно сделать проще и без дрочки:
```
#include <iostream>
using namespace std;
double weighttopounds (double kg)
{
    return 2.20462 * kg;
}
  
int main ()
{
    double weight;
    cout << "Введит ваш вес в килограммах для перевода в фунты: ";
    cin >> weight;
    cout << "Ваш вес " << weight << " кг," << " а в " "в фунтах: " << weighttopounds(weight) << endl;
}
```
**Но иногда стоит придерживаться первый вариант - когда переменную double pounds = weighttopounds(weight) нужно будет изменить/модифицировать** 

В общем случае функцию с возвращаемым значением можно использовать там, где применяется простая константа того же самого типа
![[Pasted image 20250408133603.png]]

weighttopounds() обладает полным набором функциональных возможностей:
• имеет заголовок и тело; 
• принимает аргумент; 
• возвращает значение; 
• требует прототип(первый вариант программы)

## Местоположение директивы using в программах с множеством функций
Предпочтительнее поступать так, чтобы доступ к пространству имен std был предоставлен только тем функциям, которым он действительно необходим. 
Cout используется только в функции main () , поэтому нет необходимости делать доступным пространство имен std для функции weighttopounds( )
Таким образом, директива using помещается внутри одной лишь функции main () , предоставляя доступ к пространству имен std только этой функции.

Cделать доступным пространство имен std для программы можно несколькими способами:
	•Можно поместить следующий оператор us ing перед определением функции в файле , в результате чего все содержимое· пространства имен std будет доступно для каждой функции в файле: using std namespace ; 
	• Можно поместить следующий оператор using в определение функции, в результате чего для этой функции будет доступно все содержимое пространства имен std: using std namespace ; 
	• Вместо того чтобы использовать using std namespace; можно поместить объявления using в определение функции и сделать доступным для каждой функции конкретный элемент, такой как cout:
	using std::cout ; 
	• Можно опустить директивы using и объявления полностью и указывать префикс std : : всякий раз При использовании элементов из пространства имен std: std::cout << "I 'm using cout and endl from the std name space " << std : : endl ;


> [!NOTE] У программистов на С++ есть возможность использовать различные способы назначения имен функциям, классам и переменным. Среди программистов бытуют строгие и разнообразные мнения относительно стиля написания кода
> MyFunction()
>  myfunction() 
>  myFunction() 
>  my_function() 
>  my_funct()

# Резюме
Программа на языке С++ состоит из одного или нескольких модулей, называемых функциями. Выполнение программы начинается с функции по имени main(). Функция состоит из заголовка и тела. В заголовке функции указывается, каким является возвращаемое значение(Если оно есть).
Тело функции состоит из последовательности операторов языка, заключенных в фигурные скобки ( { } ).
Операторы:
	•Оператор объявления. В операторе объявления указывается имя и тип переменной, которая используется в функции. 
	•Оператор присваивания. Этот оператор использует операцию присваивания (=) для установки значения переменной.
	•Оператор сообщения. Оператор сообщения посылает сообщение объекту, инициируя некоторое действие. 
	•Вызов функции. Вызов функции активизирует ее. Когда вызываемая функция завершает свою работу, программа возвращается к оператору в вызывающей функции, который непосредственно следует за вызовом функции.
	•Прототип функции. В прототипе функции объявляется тип возвращаемого функцией значения, а также количество и типы аргументов, передаваемых функции.
	•Оператор возврата. Оператор возврата посылает значение из вызываемой функции обратно вызывающей функции

Класс - это определяемая пользователем спецификация типа данных. В ней подробно описан способ представления информации и действия, которые могут выполняться над этими данными. Объект - это сущность, созданная в соответствии с предписанием класса, а простая переменная является сущностью, созданной в соответствии с описанием типа данных

**Человеским языком:**
Класс: Это, блядь, **чертёж**. Не дом, не комната, а именно **план**, как всё должно быть. В нём ты указываешь:
- какие **данные** (переменные, называются поля/члены)
- какие **действия** (методы/функции), можно с этими данными делать.
Объект: Это уже **реализация** твоего чертежа. Ты взял свой класс, сказал "создай мне такую штуку", и **на тебе объект** — уже реальная, рабочая хуйня, с которой можно ебаться: читать, менять, вызывать методы.

- Класс — это **рецепт пиццы**
- Объект — это **сама пицца**, которую ты уже испёк
- Простая переменная — это, скажем, **помидор** или **сыр**, то есть **один конкретный тип данных**, без логики и поведения.

```
class Car {
public:
    string brand;
    void honk() {
        cout << "Бип-бип, сука!" << endl;  }
};
int main() {
    Car lada; // вот тебе ОБЪЕКТ по классу Car
    lada.brand = "Lada Kalina";
    lada.honk(); // Вызов метода
}
```

C++ уже даёт тебе **готовые инструменты** для работы с вводом и выводом — это  `cin` и `cout`.
`cout` — это **то, куда ты что-то пишешь на экран**
`cin` — это **то, откуда ты что-то получаешь от пользователя**

Они оба — **объекты классов**, `ostream` и `istream`, соответственно. Проще говоря — это **умные штуки**, которые понимают, что ты хочешь вывести или ввести, и **автоматически преобразуют типы**, чтобы тебе не ебаться вручную.

### Когда нужен return;
1. Если функция **не возвращает НИХУЯ** — то и `return` ей, сука, **не нужен**, потому что **возвращать нечего**, логично же?
```
void sayHello() {
    cout << "Привет, долбоёб!" << endl;
    // return;  <- можешь написать, но можешь и НЕ писать
}
```
2. Иногда у тебя есть `return` **внутри условия**, но **вне его нет**. Если функция `void`, то это ок:
```
void check(int x) {
    if (x < 0) {
        cout << "Отрицательное число, пошёл нахуй!" << endl;
        return;
    }
    cout << "Число норм, живи дальше." << endl;
}
```
Если бы это была функция с типом `int`, то **ты ОБЯЗАН вернуть значение** **в любом случае** — иначе компилятор тебя выебет.
3. **Конструкторы и деструкторы** Тут `return` **вообще ЗАПРЕЩЁН**, потому что они **ничего не возвращают**:
```
class Fuck {
public:
    Fuck() {
        cout << "Конструктор. Создаю пиздец." << endl;
    }
    ~Fuck() {
        cout << "Деструктор. Всё, пиздец удалён." << endl;
    }
};
```
Ты не можешь вставить `return` ни с каким значением — **это не обычные функции**, а магические сраные методы жизненного цикла.
4. **Lambda-функции без возвращаемого значения**
Если ты используешь лямбду, и она ничего не возвращает — **нахуя там `return`?**
```
auto print = []() {
    cout << "Лямбда без возврата!" << endl;
};
```

|Тип функции|Обязателен `return`?|
|---|---|
|`void`|НЕТ, только если хочешь выйти раньше|
|`int`, `double` и т.д.|ДА, если не хочешь словить по ебалу|
|`main()`|НЕ обязателен с C++11+|
|Конструкторы/деструкторы|НЕЛЬЗЯ использовать `return`|
|Lambda без возврата|НЕ нужен|


# ГЛАВА 3 Работа с данными
**ООП — это про то, чтобы делать свои собственные типы данных**, чтобы потом работать с ними было не больно, а приятно, как с собственной игрушкой.

Типа: ты создаёшь **класс `Игрок`**, и можешь потом ебошить игроков с именем, здоровьем, оружием и т.д.  
А не держать эту кучу дерьма в отдельных переменных и пытаться не забыть, что `player_name1` и `hp_1` — это одно и то же существо.

Почему нужно сначала выучить встроенные типы? Потому что **если ты не знаешь, из чего строишь**, то какой ты нахуй строитель?
C++ уже даёт тебе **базовые строительные блоки**:
- **целые числа** (`int`, `short`, `long`)
- **плавающие числа** (`float`, `double`)
- и другие фундаментальные типы.
Типа, не прыгай в классы, пока не знаешь разницу между `int` и `unsigned long long`, понял?

Почему так много типов целых и плавающих чисел?
- Программисты — это капризные мрази.
- Одному нужен `int`, другому — 8 байт без знака, третьему — точность до 15 знаков после запятой.

После того как ты выучишь **базовые типы**, тебе начнут давать в руки:
- **Массивы** (чтобы хранить пачку чего-то)
- **Строки** (чтобы не писать имена как `char name[50]`)
- **Указатели** (чтобы ты пострадал, как все настоящие мужики в C++) 
- **Структуры** (мини-классы без методов, такие упрощённые контейнеры)

Преобразование типов
Иногда ты хочешь из `float` сделать `int`, или наоборот.  
Вот тут у тебя есть:
- **неявное преобразование** — компилятор сам делает    
- **явное** — ты ему говоришь: "Сделай, блядь, сейчас и именно так".

```
float x = 5.7;
int y = (int)x;  // y станет 5
```

- ООП = создаёшь свои типы данных, чтоб не дрочить с кучей переменных.
- Сначала учишь **встроенные типы** — потому что из них строится всё.
- C++ даёт дохера числовых типов, чтоб ты мог быть привередой.
- Потом пойдут массивы, строки, указатели — вот там и начнётся настоящий ебёж.
- Всё хранится в **переменных**, они — твои ярлыки на данные.
- Арифметика работает. С типами будь осторожен.
- Преобразование типов — когда надо подогнать одно под другое.

## Простые переменные
Как правило, программа должна хранить разнообразную информацию. Чтобы сохранить элемент информации в памяти компьютера, программа должна отслеживать три фундаментальных свойства:
	• где хранится информация; 
	• какое значение сохранено; 
	• разновидность сохраненной информации.

Предположим, что ассистент заведующего лабораторией использует следующие операторы:
```
int braincount;
braincount = 5;
```
Эти операторы сообщают программе, что она хранит целое число, а имя braincount представляет целочисленное значение, в данном случае 5.
По существу программа выделяет некоторую область памяти, способную уместить целое число, отмечает ее расположение и копирует туда значение 5.
## Имена, назначаемые переменным
В С++ приветствуется назначение переменным осмысленных имен
В именах разрешено использовать только алфавитных символов, цифр и символа подчеркивания. 
	• Первым символом имени не должна быть цифра. 
	• Символы в верхнем и нижнем регистре рассматриваются как разные. 
	• В качестве имени нельзя использовать ключевое слово С++. 
	• Имена, которые начинаются с двух символов подчеркивания или с одного подчеркивания и следующей за ним буквы в верхнем регистре, зарезервированы для использования реализациями С++. Имена, начинающиеся с одного символа подчеркивания, зарезервированы для применения в качестве глобальных идентификаторов в реализациях. 
	• На длину имени не накладывается никаких ограничений, и все символы в имени являются значащими. Однако некоторые платформы могут вводить свои ограничения на длину.
```
int poodle; 
int Poodle ;
int POODLE ;
Int terrier; // недопустимое - должно использоваться int, а не Int
int my_starsЗ
int _MystarsЗ;
int 4ever; // недопустимое, потому что начинается с цифры
int doule; // недопустимое - doule является ключе вым словом С++
int begin;
int _fools; // допустимое , но зарезервированное - начинается с двух подчерканий
int the_very_best_variabe_i_canbеversion112;
int honky-tonk; // недопустимое - дефисы неразрешены
```
Обычно если переменной назначается имя, состоящее из двух или более слов, то для разделения слов используется символ подчеркивания
```
int my_onions
```
## Целочисленные типы
Целыми являются числа без дробной части. С++ представляет множество видов и отличаются друг от друга объемом памяти , выделяемой для хранения целого значения. Чем больше объем памяти, тем шире диапазон представляемых целочисленных значений.

Обычно для описания объема памяти, используемого для хранения целого числа, применяется термин ширина. Чем больше памяти необходимо для хранения значения, тем оно шире.

В С++ базовыми целочисленными типами, в порядке увеличения ширины, являются: char, short, int, long, long long.
- **short**: Этот тип обычно занимает 2 байта памяти. Он может быть как со знаком (signed short), так и без знака (unsigned short). Диапазон значений для `signed short` — от -32,768 до 32,767, а для `unsigned short` — от 0 до 65,535.

- **int**: Это самый часто используемый тип для хранения целых чисел, который занимает 4 байта. Диапазон значений для `signed int` — от -2,147,483,648 до 2,147,483,647, а для `unsigned int` — от 0 до 4,294,967,295.

- **long**: Этот тип обычно занимает 4 байта на 32-битных системах и 8 байт на 64-битных. Диапазон значений для `signed long` на 32-битных системах — от -2,147,483,648 до 2,147,483,647, а для `unsigned long` — от 0 до 4,294,967,295. На 64-битных системах диапазон значений значительно увеличивается.

- **long long**: Этот тип был введен в C++11 и обычно занимает 8 байт. Диапазон значений для `signed long long` — от -9,223,372,036,854,775,808 до 9,223,372,036,854,775,807, а для `unsigned long long` — от 0 до 18,446,744,073,709,551,615.

- **char**: Тип `char` используется чаще всего для представления символов, но его можно использовать и для целых чисел. Он занимает 1 байт. Диапазон значений для `signed char` — от -128 до 127, а для `unsigned char` — от 0 до 255.

|Тип|Размер (байты)|Диапазон значений (signed)|Диапазон значений (unsigned)|
|---|---|---|---|
|`char`|1|-128 до 127|0 до 255|
|`short`|2|-32,768 до 32,767|0 до 65,535|
|`int`|4|-2,147,483,648 до 2,147,483,647|0 до 4,294,967,295|
|`long`|4 или 8|-2,147,483,648 до 2,147,483,647 (на 32-битных)|0 до 4,294,967,295 (на 32-битных)|
|`long long`|8|-9,223,372,036,854,775,808 до 9,223,372,036,854,775,807|0 до 18,446,744,073,709,551,615|

> [!NOTE] Память компьютера состоит из единиц, называемых битами. 
>  Представь, что самая маленькая частичка памяти в компьютере — это **бит**. Это как выключатель: либо ВКЛ (1), либо ВЫКЛ (0). 
>  Когда ты собираешь 8 таких "выключателей" (битов) вместе, получается **байт**. С помощью одного байта можно составить 256 разных комбинаций из нулей и единиц, что позволяет кодировать числа или символы. Больше битов — намного больше комбинаций и возможностей хранить более крупные числа или более сложную информацию.
>  Обычно **байт** понимают именно как 8 бит, и в байтах измеряют объем памяти (килобайты, мегабайты).
>  В языке программирования C++ под **байтом** понимается немного другое: это минимальное количество битов, которое нужно, чтобы сохранить один символ (букву, цифру, знак). Чаще всего это тоже 8 бит (для английского алфавита и стандартных символов), но для систем, поддерживающих много языков (как Unicode), C++ байт может быть и больше — 16 или 32 бита.
>  Бит — основа, байт (обычно 8 бит) — стандартная "порция" памяти для хранения данных и измерения ее объема.

```
#include <iostream>
#include <climits>
  
int main ()
{
    using namespace std;
    int n_int = INT_MAX;
    short n_short = SHRT_MAX;
    long n_long = LONG_MAX;
    long long n_long_long = LLONG_MAX;
   
   // Операция sizeof выдает размер типа или переменной
   cout << "int: " << sizeof (int) << " bytes." << endl;
   cout << "short: " << sizeof (n_short) << " bytes." << endl;
   cout << "long: " << sizeof (n_long) << " bytes." << endl;
   cout << "long long: " << sizeof (n_long_long) << " bytes." << endl;
    
    cout << "Maximum values:" << endl;
    cout << "int: " << n_int << endl;
    cout << "short: " << n_short << endl;
    cout << "long: " << n_long << endl;
    cout << "long long: " << n_long_long << endl;
    cout << "\n";
   
	cout << "Minimal int value = " << INT_MIN << endl;
    cout << "Bits per byte = " << CHAR_BIT << endl;
    return 0;
}
```

>int: 4 bytes.
short: 2 bytes.
long: 4 bytes.
long long: 8 bytes.
Maximum values:
int: 2147483647
short: 32767
long: 2147483647
long long: 9223372036854775807
Minimal int value = -2147483648
Bits per byte = 8

### Операция sizeof и заголовочный файл climits
Операцию sizeof можно применять к имени типа или к имени переменной.
```
cout « "int is " << sizeof (int ) << " bytes.\n ";
cout << "short is " << sizeof n_short << "bytes.\n";
```
Заголовочный файл climits определяет символические константы для представления ограничений типов. INT_МAX представляет наибольшее значение, которое может хранить тип int(можно применять к любым типам данных).

| Символическая константа | Представление                            |
| ----------------------- | ---------------------------------------- |
| CHAR_BIT                | Количество битов в char                  |
| CHAR_MAX                | Максимальное значение char               |
| CHAR_MIN                | Минимальное значение char                |
| SCHAR_MAX               | Максимальное значение signed char        |
| SCHAR_MIN               | Минимальное значение signed char         |
| UHAR_MAX                | Максимальное значение unsigned char      |
| SHRT_MAX                | Максимальное значение short              |
| SHRT_MIN                | Минимальное значение short               |
| USHRT_MAX               | Максимальное значение unsigned short     |
| INT_MAX                 | Максимальное значение int                |
| INT_MIN                 | Минимальное значение int                 |
| UINT_MAX                | Максимальное значение unsigned int       |
| LONG_MAX                | Максимальное значение long               |
| LONG_MIN                | Минимальное значение long                |
| ULONG_MAX               | Максимальное значение unsigned long      |
| LLONG_MAX               | Максимальное значение long long          |
| LLONG_MIN               | Минимальное значение long long           |
| ULLONG_MAX              | Максимальное значение unsigned long long |


> [!NOTE] Символические константы как средство препроцессора
> В файле cl imits содержатся строки, подобные следующей:
> #define INT_MAX 32767;
> Cообщает препроцессору следующее: найти в программе экземпляры символической константы INT МАХ и заменить каждое вхождение значением 3276 7

### Инициализация
При инициализации комбинируется присваивание и объявление. 
```
int n_int = INT_MAX;
```
Объявление переменной n_int и присваиваание ей наиблоьшее допустимое значение int.

Можно инициализировать переменную другой переменной, при условии , что эта другая переменная уже была объявлена. Можно даже инициализировать переменную выражением, при условии, что все значения в выражении известны на момент объявления:
```
int uncless = 5;
int aunts = uncles;
iny chairs aunts + uncles + 4;
```
Синтаксис инициализации , показанный в предыдущем примере, заимствован из С; в языке С++ используется еще один синтаксис инициализации, не совместимый с С:
```
int owls = 101; // сишный
int wrens(432); // плюшный
```
Если вы знаете, каким должно быть исходное значение переменной, инициализируйте ее
```
short year;
year = 1488;
```
# Инициализация в С++11
Существует другой формат для инициализации , который используется с массивами и структурами, переменными имеющими единственное значение. Он предоставляет лучшую защиту от ошибок преобразования типов.  **И САМЫЙ ЛУЧШИЙ**
```
int hamburgers = {24};
```
Фигурные скобки можно оставить пустыми , тогда переменная будет инициализироваться 0:
```
int rocs{} // = 0
```
## Типы без знаков
Каждый из четырех целочисленных типов имеет беззнаковую версию, которая не может хранить отрицательные значения. За счет этого можно увеличить наибольшее значение, которое способна хранить переменная. 
Естественно, типы без знаков следует использовать только для тех величин, которые никогда не будут отрицательными.
```
unsigned short change;
unsigned int revort;
unsigned quarterback; // тоже int
unsigned long gone;
unsigned long long lang_lang;
```
**Указание просто unsigned является сокращением для unsigned int**
## Выбор целочисленного типа
Если переменная представляет какую-то величину, которая никогда не будет отрицательной, можно использовать тип без знака;
Если вы знаете, что переменная будет содержать целочисленные значения, слишком большие для 16-битного целочисленного типа, применяйте тип long
Если же вы имеете дело с очень большими значениями, выберите тип long long.
Использование типа short позволит сократить потребление памяти, если short занимает меньше пространства, чем int.
Если перед вами действительно встает вопрос экономии памяти, то вместо типа int предпочтительнее использовать тип short

## Целочисленные литералы
да пiхуй, смари на 98 странице. хуня

# Тип char: символы и короткие целые числа
char предназначен для хранения символов, таких как буквы и цифры. Для целевой компьютерной системы гарантируется , что char будет настолько большим, чтобы представлять весь диапазон базовых символов - все буквы, цифры, знаки препинания и т.п.

```
#include <iostream>
  
int main ()
{
    using namespace std;
    char ch;
    cout << "Write a character: ";
    cin >> ch;
    cout << "Hola! ";
    cout << "Thank you for the " << ch << " character!" << endl;
    return 0;
}
```
Интересный момент здесь в том, что вы вводите символ М, а не соответствующий код символа 77.
Вдобавок, если заглянуть в память, выяснится, что 7 7 - это значение, которое хранится в переменной ch. Подобного рода "магия" связана не типом char, а с объектами cin и cout, которые выполняют все необходимые преобразования. На входе объект cin преобразует нажатие клавиши <М> в значение 77 . На выходе объект cout преобразует значение 7 7 . для отображения символа м
Ещё один пример:
```
#include <iostream>
  
int main ()
{
    using namespace std;
    char ch;
    cin >> ch
    int i;
    cout << "The ASCII coed of the character for "<< ch << " is" << endl;
    cout << "Add one to the character code character" << endl;
    ch +=1;
    i = ch;
    cout << "The ASCII code of the character for "<< ch << " is " << i << endl;
    cout << "Displaying char ch using cout.put(ch): ";
    //Использование cout.put() для отображения символьной константы
    cout.put(ch);
    cout.put('!');
    cout << endl << "Done" << endl;
    return 0;
}
```

### Функция-член: cout .put()
Эта функция является самым первым примером важной концепции ООП - это функция-член.
Вспомните , что класс определяет способ представления данных и действия, которые можно над ними выполнять. Функция-член принадлежит к классу и описывает способ манипулирования данными класса.
Представь, что **класс** (ostream в данном случае) — это как **чертёж автомобиля**. В чертеже описано, из чего машина состоит (данные) и что она умеет делать (действия, функции).
**Объект** (cout в данном случае) — это **конкретный автомобиль**, собранный по этому чертежу. У нас есть стандартный автомобиль для вывода на консоль — его зовут cout.
**Функция-член** (put() в данном случае) — это одно из **действий, которое умеет делать автомобиль**, согласно чертежу. Например, "завести двигатель", "посигналить", "включить фары". Функция put() — это действие "вывести один символ".
Теперь самое главное: ты не можешь просто "завести двигатель" в вакууме. Ты должен завести двигатель **у конкретного автомобиля**. Точно так же ты не можешь просто выполнить действие "вывести символ" (put()). Ты должен сказать, **какой именно объект** (какой "автомобиль") должен это сделать.
Вот тут и появляется **точка (.)**. Она как бы говорит: **"Эй, вот этот объект (cout), сделай-ка вот это действие (put())".**
cout.put('A') буквально означает:  
**"Возьми объект cout (наш стандартный консольный вывод) и используй его умение put() (вывести один символ), чтобы вывести символ 'A'".**

Функция-член cout.put() предлагает альтернативу применению операции << для отображения символа.

Коды управляющих последовательностей в С++

| Название Символа         | ASCII | C++ |
| ------------------------ | ----- | --- |
| Новая строка             | NL    | \n  |
| Горизонтальная табуляция | HT    | \t  |
| Вертикальная табуляцию   | VT    | \v  |
| Забой                    | BS    | \b  |
| Возврат карнтка          | CR    | \r  |
| Предупреждение           | BEL   | \a  |
| Обратная косая черта     | \     | \ \ |
| Знак вопроса             | \     | \ ? |
| Одинарная кавычка        | '     | \ ' |
| Двойная кавычка          | "     | \ " |
|                          |       |     |
### Универсальные символьные имена
хуйня какая-то 
107 стр

## Типы signed char и unsigned char
В отличие от int, тип char по умолчанию не имеет знака. 
Если для вас крайне важно, чтобы тип char обладал определенным поведением, можете использовать типы signed char и uns igned char явным образом
```
char fodo; // может быть со знаком, а может быть и без знака
unsigned char bar; // беззнаковый тип
signed char snarh; // явно указание типа со знаком
```
Эти отличия будут особенно важными, если тип char используется в качестве числового типа. Тип unsigned char обычно представляет диапазон значений от О до 255 , а signed char - диапазон от -128 до 1 27.
### На случай, если требуется больше: wchar_ t
**во многих системах `char` — это просто 8-битная жопа, которая не справляется с чем-либо сложнее ASCII**. А когда ты сталкиваешься с чем-то по-настоящему интересным, типа:
- Японских кандзи
- Китайских иероглифов
- Эмодзи 🤡
- Или даже ёбаных ударений в испанском — всё, пиздец, `char` умирает.
Вот тогда и появляется **`wchar_t` — wide character**, как супер-заряженный мутант обычного `char`:
- Он может быть **16-битным** или **32-битным**, в зависимости от системы.
- Он тащит на себе весь Unicode-карнавал.
- Его задача — **представлять символы, которые просто не влезают в 8-битный карман `char`'а**.
`wchar_t` — это **полнейшее проклятие, если ты не знаешь, что делаешь**:
- Он **не стандартен по размеру**. Где-то это `unsigned short`, где-то `int`, а где-то вообще 4 байта, **как бог на душу положит**.
- На практике ты быстро поймёшь, что **хуже, чем `wchar_t`, может быть только `Windows API`**.
Поэтому современные кодеры, которые не хотят ебаться с костылями, **используют `char16_t`, `char32_t`, и UTF-поддержку через библиотеки типа ICU, Boost.Locale и т.д.**

```
wchar_t bob = L'P';
wcout << L"tall" << endl; // вывод строки wchar_t
```
### Новые типы в С++1 1: char16_t и char32_t
wchar_t полная хуйня, как и char. По этому появляется char16_t и 32_t
```
char16_t ch1 = u'q';
char32_t ch2 = U'/U0000222b';
```

### ВЫВОД ЭТОГО ЧУДА😈:
Для `char32_t` можно написать такую поебень:
```
#include <iostream>
#include <string>

std::string utf8_encode(char32_t cp) {
    std::string result;
    if (cp <= 0x7F) {
        result += static_cast<char>(cp);
    } else if (cp <= 0x7FF) {
        result += static_cast<char>(0xC0 | (cp >> 6));
        result += static_cast<char>(0x80 | (cp & 0x3F));
    } else if (cp <= 0xFFFF) {
        result += static_cast<char>(0xE0 | (cp >> 12));
        result += static_cast<char>(0x80 | ((cp >> 6) & 0x3F));
        result += static_cast<char>(0x80 | (cp & 0x3F));
    } else if (cp <= 0x10FFFF) {
        result += static_cast<char>(0xF0 | (cp >> 18));
        result += static_cast<char>(0x80 | ((cp >> 12) & 0x3F));
        result += static_cast<char>(0x80 | ((cp >> 6) & 0x3F));
        result += static_cast<char>(0x80 | (cp & 0x3F));
    }
    return result;
}

int main() {
    char32_t symbol = U'😈';
    std::cout << utf8_encode(symbol) << std::endl; // Выведет эмодзи
}
```
Вариант 2: **Использовать fmtlib (aka  fmt:(:)print)**
Если ты не хочешь писать говно руками — ставь [**fmtlib**](https://github.com/fmtlib/fmt), потому что стандартная библиотека — это хуй без яиц, а `fmtlib` реально умеет:
```
#include <fmt/core.h>
int main() {
    char32_t evil = U'😈';
    fmt::print("Вот тебе: {}\n", evil);
}
```

| Тип      | cout | wcout | fmtlib | ручная перекодировка |
| -------- | ---- | ----- | ------ | -------------------- |
| char     | ✅    | ✅     | ✅      | ❌                    |
| wchar_t  | ❌    | ✅     | ❌      | ❌                    |
| char16_t | ❌    | ❌     | ✅      | ТЯЖЕЛО               |
| char32_t | ❌    | ❌     | ✅      | ✅                    |
# Тип bool
Во время вычислений булевская переменная может принимать два значения: true (истина) или false (ложь). 
```
boll is ready = true;
```
Литералы true и false могут быть преобразованы в тип int, причем true преобразовывается в 1, а false в 0:
```
int ans = true; //  = 1
int promise = false // = 0
```
Кроме того, любое числовое значение или значение указателя может быть преобразовано неявно (т.е. без явного приведения типов) в значение bool. Любое ненулевое значение преобразуется в true, а нулевое значение - в false:
```
bool start = -100; // true
bool stop = 0; // false
```

**Логика тут простая как говно:**
- `0` — это **"ничего", "отсутствие", "пусто", "false"**.
- Всё остальное — хоть `1`, хоть `-666`, хоть `69`, хоть `0xDEADBEEF` — это **"что-то", значит, "true"**.

 x < 0 > x = true

## Константы: const
в языке С++ имеется более удобный способ поддержки символьных констант. Этот способ предусматривает использование ключевого слова **const** для изменения объявления и инициализации переменной.
```
const int Month = 12;
```
**Общепринятая практика пре/\усматривает применение заглавной буквы в начале имени , чтобы Months можно было легко идентифицировать как константу. Это соглашение не является универсальным, однако при чтении кода программы оно помогает различать константы и переменные**

Общая форма для создания константы выглядит следующим образом:
```
const type name = value;
```
Обратите внимание, что константа инициализируется в объявлении. Показанный ниже код не годится:
```
const int Toes;
toes = 10;
```
Если не предоставить значение во время объявления константы, опа получит неопределенное значение, которое не удастся изменить

## Числа с плавающей точкой
Они поддерживают намного более широкий диапазон значений. Если число слишком большое, чтобы его можно было представить с помощью типа long, например, количество бактериальных клеток в теле человека (свыше 1 000 000 000 000) , можно воспользоваться одним из типов с плавающей точкой.

**Типы с плавающей точкой позволяют представить такие числа, как 2.5, 3.141592 и 122442.32 - т.е. числа с дробными частями. Такие значения хранятся в памяти компьютера в виде двух частей. Одна часть представляет значение, а другая - масштабный коэффициент, который увеличивает или уменьшает значение.**
Масштабный коэффициент предназначен для перемещения десятичной точки , откуда и пошел термин *плавающая точка*

В С++ поддерживаются два способа записи чисел с плавающей точкой.
```
12.34
939001.32
0.000023
8.0
```
Другой способ представления значений с плавающей точкой называется экспоненциальной записью и имеет вид, подобный следующему: 3.45Е6. Эта запись означает, что значение 3.456 умножается на 1 000 000.; E6 - 10^6, 
**В данном случае 6 называется порядком, а 3.45 - мантиссой.**
```
2.52e+8 // + необязателен
8.33E-4 // порядок может быть отрицателньм
7E5
-18.32e13 // 
1.69e12
5.98e24 // масса земли в КГ
9.11e-31 // масса электрона в КГ
```
Экспоненциальная запись гарантирует, что число будет храниться в формате с плавающей точкой, даже при отсутствии десятичной точки. Обратите внимание, что можно использовать Е либо е , а порядок может быть как положительным, так и отрицательным

**Однако пробелы в записи не разрешены, поэтому, например, вариант 7. 2 Е6 является недопустимым.**
![[Pasted image 20250410120856.png]]
Отрицательное значение порядка означает деление, а не умножение на степень 10. Таким образом, 8.33Е-4 означает 8.33/104, или 0. 000833.
Выбирайте тот вариант, который вам больше нравится

Язык С++ поддерживает три типа чисел с плавающей точкой: float, double и long double
обычно float занимает 32 бита, douЬle - 64 бита, а long double - 80, 96 или 128 битов

Ограничения для конкретной системы можно узнать , заглянув в файл c float или float.h. (Файл cfloat является аналогом файла float.h в С.) Ниже в качестве примера приведены некоторые строки из файла float.h для Borland C++Builder:

```
{
    #define DBL_DIG 15 // DOUBLE
    #define FLT_DIG 6 // FLOAT
    #define LDBL_DIG 18 // LONG DOUBLE
    // КОЛ-ВО БИТОВ, ИСП. ДЛЯ ПРЕДСТАВЛЕНИЯ МАНТИССЫ
    #define DBL_MANT_DIG 53 // DOUBLE
    #define FLT_MANT_DIG 24 // FLOAT
    #define LDBL_MANT_DIG 64 // LONG DOUBLE
    // МАКСИ И МИН ЗНАЧ. ПОРЯДКА
    #define DBL_MAX_EXP_10 + 308
    #define FLT_MAX_EXP_10 + 38
    #define LDBL_MAX_EXP_10 + 4932
    #define DBL_MIN_EXP_10 - 307
    #define FLT_MIN_EXP_10 - 37
    #define LDBL_MIN_EXP_10 - 4931
}
```
показан пример использования типов float и double и продемонстрированы также их различия в точности, с которой они представляют числа (т.е. количество значащих цифр)

В данном примере вызов этого метода устанавливает формат вывода с фиксированной точкой, который позволяет визуально определять точность. Это предотвратит переключение на экспоненциальную запись для больших чисел и заставит отображать шесть цифр справа от десятичной точки. Аргументы ios_base::fixed и ios_base::float field - это константы
```
// floatnum.cpp -- типы с плавающей точкой
#include <iostream>
int main ()
{
    using namespace std;
    cout.setf(ios_base::fixed, ios_base::floatfield) ;
    float tub = 10.0/3.0 ;
    double mint = 10.0/3.0;
    const float million = 1.0e6;
    cout << "tub = " << tub;
    cout << ", а million tubs = " << million * tub;
    cout << ",\nand ten million tubs = ";
    cout << 10 * million * tub << endl ;
    cout << "mint = " << mint << " and а million mints = ";
    cout << million * mint << endl ;
    return 0;
}
```
Эта система гарантирует 6 значащих цифр для float -  это самый худший сценарий. Переменная типа double показывает 13 троек, поэтому она дает хороший результат до 13-й значащей цифры. Поскольку система гарантирует 15 значащих цифр, то такой и должна быть точность этого типа.

**Когда в программе записывается константа с плавающей точкой, то с каким именно типом она будет сохранена? По умолчанию константы с плавающей точкой , такие как 8. 24 и 2. 4Е8, имеют тип douЬle. Если константа должна иметь тип float, необходимо указать суффикс f или F. Для типа long double используется суффикс l или L**

```
1.234f // float
2.45E20F // float
2.345324E28 // double
2.2L // long double
```

Числа с плавающей точкой обладают двумя преимуществами по сравнению с целыми числами. Они могут представлять значения, расположенные между целыми числами и у них есть масштабный коэффициент, они могут представлять более широкий диапазон значений. 
С другой стороны, операции с плавающей точкой обычно выполняются медленнее , чем целочисленные операции, и могут приводить к потере точности.

## Арифметические операции в С++
(+) выполняет сложение операндов
(-) вычитает второй операнд из первого
(\*) умножает операнды.
(/) выполняет деление первого операнда на второй, отбрасывает дробную часть
(%) находит остаток от деления первого операнда на второй


## Преобразование при инициализации и присваивании
Язык С++ довольно либерален, разрешая присваивание числового значения одного типа переменной другого типа. Всякий раз, когда вы это делаете , значение преобразуется к типу переменной, которая его получает
```
so_long = thirty; // short to long
```
**Потенциальные проблемы при преобразовании чисел**

| Тип преобразования                                                                        | Возможные проблемы                                                                                                                                    |
| ----------------------------------------------------------------------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------- |
| Больший тип с плавающей точкой в меньший тип с плавающей точкой, например, double в float | Потеря точности (значащих цифр); исходное значение может превысить диапазон , допустимый для целевого типа, поэтому результат окажется неопределенным |
| Тип с плавающей точкой в целочисленный тип                                                | Потеря дробной части                                                                                                                                  |
| Больший целочисленный тип в меньший целочисленный тип, например, long в short             | Исходное значение может превысить диапазон, допустимый для целевого типа;                                                                             |

### Преобразование при инициализации с помощью {} 
В С++ 11 инициализация, при которой используются фигурные скобки, называется списковой инициализацией. Списковая инициализация не допускает сужение, при котором тип переменной может быть не в состоянии представить присвоенной значение.
**Например, преобразования типов с . плавающей точкой в целочисленные типы не разрешены. Преобразование из целочисленных типов в другие целочисленные типы или типы с плавающей точкой может быть разрешено, если компилятор имеет возможность сообщить, способна ли целевая переменная корректно хранить значение.**
```
const int code = 66; 
int x = 66;
char c1 {31325}; // сужение, не разрешено
char c2 = {66}; // разрешено, char может хранить это значение
char c3 {code}; // тоже самое
char c4 {x}; // х не является константой
x = 31325;
char c5 = x; // разрешено
```
При инициализации с4 известно, что х имеет значение 66 , но для компилятора х - это переменная , которая предположительно может иметь какое-то другое , намного большее значение. В обязанности компилятора не входит отслеживание того , что может произойти с переменной х между моментом ее инициализации и моментом , когда она задействована в попытке инициализации с4.

### Преобразования при передаче аргументов
Например, чтобы преобразовать значение int, хранящееся в переменной по имени thorn, в тип long:
```
(long) thorn // возвращает результат преобра зования thorn в тип long
long (thorn) // возвращает результат преобра зования thorn в тип long
```
Приведение типа не изменяет значение самой переменной thorn; вместо этого создается новое значение указанного типа , которое затем можно использовать в выражении:
```
cout << int('Q'); // Целочисленный код для Q
```

В общих чертах можно делать следующее:
```
(имяТипа) значение // преобразует значение в тип имяТипа
имяТипа (значение) // преобразует значение в тип имяТипа
```
Первая форма представляет стиль С, а вторая - стиль С++. Идея новой формы заключается в том, чтобы оформить приведение типа точно так же , как и вызов функции

# С++ также предлагает четыре операции приведения типов с более ограниченными возможностями применения.
1. **static_cast** (статическое приведение типов)
```
int i = 10;
static_cast<double> (i) // возвращает результат преобразования i в тип double
```

```
#include <iostream>
int main ()
{
    using namespace std;
    int age = 10;
    double f = static_cast<double>(age);
    cout << f << endl;
    return 0;
}
```
Если дробная часть равна `0`, компилятор C++ по умолчанию выведет **целое число** без дробной части. То есть, если переменная типа `double` хранит значение, эквивалентное целому числу (например, `10.0`), вывод будет происходить без отображения десятичной точки. Это поведение связано с **форматом вывода по умолчанию**.

2. **dynamic_cast** (динамическое приведение типов)
Эта операция используется только для указателей или ссылок на объекты, связанные наследованием. Она проверяет, является ли объект настоящим экземпляром производного класса, и выполняет безопасное приведение типов. В случае неудачного приведения возвращается `nullptr` (для указателей) или выбрасывается исключение `std::bad_cast` (для ссылок).
```
class Base { virtual void func() {} };
class Derived : public Base {};

Base* base = new Derived();
Derived* derived = dynamic_cast<Derived*>(base);  // Безопасное приведение
if (derived) {
    // Приведение успешно
}

```

3. **const_cast** (приведение константности)
Операция `const_cast` используется для добавления или удаления квалификатора `const` у переменной. Это позволяет изменять данные, которые были объявлены как константные, но при этом следует быть осторожным, поскольку это может привести к неопределенному поведению.
```
const int a = 10;
int* b = const_cast<int*>(&a);  // Удаление const
*b = 20;  // Может привести к неопределенному поведению

```

4. **reinterpret_cast** (переинтерпретация типов)
Это наиболее мощная и опасная операция приведения типов. Она позволяет интерпретировать один тип как другой, даже если они не имеют общих представлений в памяти. Обычно используется для приведения указателей к различным типам или преобразования данных между не совместимыми типами. Однако применение `reinterpret_cast` требует осторожности, так как оно может привести к некорректному поведению программы.
```
int i = 42;
char* p = reinterpret_cast<char*>(&i);  // Переинтерпретация указателя
```
**Ограничения и предостережения:
- **static_cast** — безопасен, но только при условии, что типы совместимы.
- **dynamic_cast** — ограничен указателями/ссылками и требует наличия виртуальных функций в базовом классе (для полиморфизма).
- **const_cast** — может быть использован только для изменения квалификаторов `const`, но должен применяться с осторожностью.
- **reinterpret_cast** — предоставляет максимальную гибкость, но является самым опасным способом приведения типов.


**В большинстве случаев операции приведения типов в C++ не нужны**. Максимум для:
- При работе с указателями, классами или изменении `const`-квалификаторов, использование приведения типов может быть необходимо для безопасного и явного управления типами.

```  
#include <iostream>
int main ()
{
    using namespace std;
    int auks, bats, coots ;
    // следующий оператор суммирует значения типа doube ,
    // а полученный результат преобразуется в тип int
    auks = 19.99 + 11.99;
    // эти операторы суммируют целочисленные
    bats = (int) 19.99 + (int) 11.99;
    coots = int (19.99) + int (11.99);
    cout << "auks = " << auks << ", bats = " << bats;
    cout << ", coots = " << coots << endl;
    char ch = 'Z' ;
    cout << " The code for " << ch << " is ";
    cout << int(ch) << endl;
    cout << " Yes, the code is ";
    cout << static_cast<int>(ch) << endl ;
    return 0;
}
```
>auks = 31, bats = 30, coots = 30
 The code for Z is 90
 Yes , the code i s 90

В двух операторах cout приведения типов применяются для преобразования значений char в int перед их отображением. Эти преобразования приводят к тому, что cout выведет значение в виде целого числа, а не символа. ch типа char хранит код буквы Z. Использование cout для вывода ch приводит к отображению буквы z , поскольку cout концентрирует внимание на факте принадлежности переменной ch к типу char. Однако за счет приведения ch к типу int объект cout переключается на режим int
*В этой программе проиллюстрированы две причины использования приведения типов. Скажем, у вас могут быть значения, которые хранятся в формате douЫe, по используются для вычисления значения int. Например, требуется привязка к позиции на сетке или моделирование целочисленных значений, таких как размер популяции, с помощью значений с плавающей точкой. Может понадобиться, чтобы в вычислениях все значения трактовались как int. Все это позволяет сделать приведение типов.*

### auto
Позволяет компилятору выводить тип из типа значения инициализации. Просто укажите auto вместо имени типа в инициализирующем объявлении, и компилятор назначает переменной тот же самый тип, что у инициализатор:
```
auto n = 100; // int
auto x = 1.5; // double
auto y = 1.3e12L; // long double
```
Однако это автоматическое выведение типа на самом деле не предназначено для таких простых случаев. В действительности можно даже запутаться. Например, предположим, что х, у и z должны относиться к типу douЫe. Взгляните на следующий код:
```
auto x = 0.0 // x - double, 0.0 - double
double y = 0 // 0 преобразуется в 0.0
auto z = 0; // z = int, 0 - int
```
Использование 0 вместо 0.0 не вызывает проблем при явном указании типов, но приводит к ним в случае автоматического преобразования типов.

**Автоматическое выведение типа становится более полезным, когда приходится иметь дело со сложными типами, такими как применяемые в стандартной библиотеке шаблонов (STL)**:
```
C++98
std::vector<double> scores;
std::vector<double>::iterator pv = score.begin();
```

```
C++11
std::vector<double> scores;
auto pv = score.begin();
```

# STL
**STL (Standard Template Library)** — это стандартная библиотека шаблонов C++. Она содержит готовые **контейнеры данных** (массивы, списки, словари и т.п.), **алгоритмы** (сортировка, поиск и т.д.) и **итераторы** (указатели на элементы контейнеров).
Примеры контейнеров из STL:
- `std::vector` — динамический массив (типа `ArrayList` в Java или `list` в Python).
- `std::list` — двусвязный список.
- `std::map` — словарь (ассоциативный массив).
- `std::set` — множество.

STL — это просто набор "умных массивов"
Обычный массив:
```
int arr[5] = {1, 2, 3, 4, 5};
```
Но он неудобный. Нельзя менять размер, не хватает фишек.
**STL даёт тебе "прокачанные массивы"**, типа вот этого:
```
std::vector<int> nums = {1, 2, 3, 4, 5};
```
И теперь можно:
- добавлять элементы (`nums.push_back(6);`)
- удалять (`nums.pop_back();`)
- перебирать (`for (int x : nums) cout << x;`)


`scores.begin()` — это типа “первый элемент массива” (пример из главы auto)
```
std::vector<double> scores = {10.5, 20.7, 30.9};
auto it = scores.begin();   // it — это "указатель" на 10.5

std::cout << *it;  // покажет 10.5
++it;
std::cout << *it;  // теперь 20.7
```

`auto` просто говорит: “Компилятор, сам разберись с типом”
Чтобы не писать длинные штуки вроде:
```
std::vector<double>::iterator it = scores.begin();
```
Ты пишешь просто:
```
auto it = scores.begin();
```
**НАДО СЮДА ДОБАВИТЬ**

резюме - 128


























































































































































