**VSCODE:**
**// USE GOOGLE TRANSLATE: ALT+SHIFT+T**
**// USE GOOGLE SEARCH:  CTRL + ALT + G**
### Демонстрационная программа
```
#include <stdio.h>
int main(void)
{
    float weight; /* вес пользователя */
    float value; /* платиновый эквивалент */
    printf("Хотите узнать свой вес в платиновом эквиваленте?\n");
    printf("Давайте подсчитаем.\n");
    printf("Пожалуйста, введите свой вес, выраженный в фунтах: ");
    /* получить входные данные от пользователя */
    scanf("%f", &weight);
    /* считаем, что цена родия равна $1700 за тройскую унцию */
    /* 14.5833 коэффициент для перевода веса, выраженного в фунтах, в тройские унции */
    value = 1700.0 * weight * 14.5833;
    printf("Ваш вес в платиновом эквиваленте составляет $%.2f.\n", value);
    printf("Вы легко можете стать достойным этого! Если цена платины падает,\n");
    printf("ешьте больше для поддержания своей стоимости.\n" );
    return 0;
}
```
Ниже приведен пример вывода программы: 
```
Хотите узнать свой вес в платиновом эквиваленте?
Давайте подсчитаем. 
Пожалуйста, введите свой вес, выраженный в фунтах: 156 
Ваш вес в платиновом эквиваленте составляет $3867491.25. 
Вы легко можете стать достойным этого! Если цена платины падает, ешьте больше для поддержания своей стоимости.
```
![[Pasted image 20250402160608.png]]

## Переменные и константы
программа должна работать с данными, т.е. числами и символами, несущими в себе необходимую информацию. Некоторые виды данных устанавливаются до начала выполнения программы и их значения сохраняются неизменными в течение всего времени ее работы. Такие данные называются *константами*. Другие виды данных могут изменяться в ходе выполнения программы. Они называются *переменными*
## Kлючевые слова для типов данных
Помимо отличий между переменными и константами, существует также разница между разных типами данных. Одни данные являются числами. Другие данные представляют собой буквы или, в общем случае, символы. Компьютеру необходим способ идентификации и использования этих разных видов данных. В языке С для этого предусмотрено несколько базовых типов данных.

| Ключевые слова в исходном стандарте K&R | Ключевые слова С90 | Ключевые слова С99 |
| --------------------------------------- | ------------------ | ------------------ |
| int                                     | signed             | _Bool              |
| long                                    | void               | _Complex           |
| short                                   |                    | _Imaginary         |
| unsigned                                |                    |                    |
| char                                    |                    |                    |
| float                                   |                    |                    |
| double                                  |                    |                    |
Ключевым словом int обозначается основной класс целых чисел, применяемых в С. Следующие три ключевых слова ( long, short и unsigned) и signed используются для указания вариаций этого базового типа, например, unsigned short int и long long int .
С помощью ключевого слова char определяются символьные данные, к которым относятся буквы алфавита и другие символы, такие как #, $, % и . Тип данных char можно также применять для представления небольших целых чисел. 
Типы float, double и long double служат для представления чисел с плавающей запятой. Тип данных Bool используется для булевских значений (true и false) , а типы данных Complex и Imaginary представляют, соответственно, комплексные и мнимые числа
> [!NOTE] Биты, байты и слова
> Для описания элементов компьютерных данных или элементов компьютерной памяти могут применяться термины бит, байт и слово. 
> Минимальная единица памяти называется битом, который может хранить одно из двух значений: 0 или 1. (Иногда говорят, что бит “включен” или “выключен”.) Конечно, водном бите много информации сохранить не получится, но в компьютере их имеется огромное количество. Бит является базовым строительным блоком для памяти компьютера
> Байт — это наиболее часто используемая единица памяти компьютера. Практически на всех машинах байт состоит из 8 битов, и это является стандартным определением байта, по крайней мере, когда речь идет об измерении объема памяти. Поскольку бит может принимать значение 0 или 1, байт обеспечивает 256 (т.е. 2^8) возможных комбинаций нулей и единиц.
> Слово — это естественная единица памяти для компьютера конкретного типа. В 8-разрядных микрокомпьютерах, слово состояло из 8 битов. С тех пор персональные компьютеры перешли на 16-битные, 32-битные, а в настоящее время и 64-битные слова. Большие размеры слова позволяют быстрее передавать данные и делают доступным больший объем памяти.
## Базовые типы данных языка С
### Тип int
Тип int представляет целое число со знаком. Это значит, что оно должно быть целым и может иметь положительную, отрицательную или нулевую величину.
Для объявления целочисленных переменных применяется ключевое слово in t. Сначала указывается ключевое слово in t, затем выбранное имя для переменной и, наконец, точка с запятой:
```
int earns;
int hogs, cows, goats;
```
Для каждой переменной можно было бы предусмотреть отдельное объявление или же объявить вес четыре переменных в одном операторе. Результат будет таким же: связывание имен с выделенными областями памяти для четырех переменных типа int.

Иницишизацш переменной означает присваивание ей начального значения. В языке С это можно делать в виде части объявления. Достаточно после имени переменной поместить операцию присваивания (=) и указать значение, которое переменная должна получить:
```
int age = 21;
inr dogs, cats = 21;
```
В последней строке инициализируется только переменная cats:
![[Pasted image 20250402161706.png]]
### Константы типа int
Различные целые числа (21, 32, 14 и 94) в последнем примере являются *целочисленными константами*, также называемыми *целочисленными литералами*. Когда вы записываете число без десятичной точки и порядка, компилятор С распознает его как целое. Следовательно, числа 22 и -44 являются целочисленными константами, а числа 22.0 и 2.2E1 — нет
### Вывод значений типа int
Для вывода значений типа int можно применять функцию **printf()**.
Конструкция %d называется спецификатором формата, поскольку она определяет формат, используемый функцией **printf()** для отображения конкретного значения. Таким значением может быть переменная int. 
```
#include <stdio.h>
int main(void)
{
    int ten = 10;
    int two = 2;
    printf("%d - %d = %d\n", ten, 2, ten - two);
    return 0;
```

```
#include <stdio.h>
int main()
{
    signed int x = 10;
    printf("x = %d\n", x);
    return 0;
}
```
### Другие целочисленные типы
В языке С применяются три ключевых слова, модифицирующих базовый целочисленный тин: short, long и unsigned:
- Тип short int, или short, может использовать меньший объем памяти, чем int, и тем самым экономить память в случае, когда требуются только небольшие числа. Подобно int, short является типом со знаком.
- Тип long int, или long, может занимать больший объем памяти, чем int, позволяя представлять крупные целочисленные значения. Подобно int, long является типом со знаком.
- Тип long long int, или long long, может занимать больше памяти, чем long. Для этого типа используются минимум 64 бита. Подобно int, long long является типом со знаком.
- Тип unsigned int, или unsigned, применяется для переменных, которые принимают только неотрицательные значения. Этот тип сдвигает диапазон хранимых чисел. Например, 16-битный тип unsigned int имеет диапазон значений от 0 до 65535 вместо диапазона от -32768 до 32767. Бит, который использовался для представления знака, теперь становится еще одной двоичной цифрой, делая возможным представление большего числа.
- Ключевое слово signed может применяться с любыми типами со знаком, чтобы явно указать свое намерение. Например, short, short int, signed short и signed short int являются именами одного и того же типа
### Объявление переменных других целочисленных типов
```
long int estine; 
long johns; 
short int erns;
short ribs;
unsigned int s_count;
unsigned players; 
unsigned long headcount; 
unsigned short yesvotes; 
long long ago;
```
### Константы long и long long
Обычно, когда в коде программы используется число вроде 2345, оно хранится в памяти как относящееся к типу int. А что произойдет, если указать число, такое как 1 000 000, в системе, где тип int не способен хранить настолько большое значение? В этом случае компилятор трактует его как число типа long int, предполагая, что этого типа окажется достаточно. Если число превосходит максимально возможное значение типа long, оно будет рассматриваться как значение типа unsigned long. Если и этого не достаточно, оно интерпретируется как значение типа long long или unsigned long long, если данные типы доступны.
### Вывод значений типов sh o rt, long, long long и unsigned
Для вывода чисел типа unsigned int применяйте спецификатор %u. 
Чтобы вывести значение типа long, используйте спецификатор формата %ld
%lx для вывода целого числа типа long в шестнадцатеричном формате; и спецификатор %lo — для его вывода в восьмеричном формате.
long long, для версий со знаком и без знака применяются спецификаторы %lld и %llu.

В языке С доступны дополнительные форматы для printf(). Первым делом, можно применять префикс h для значений типа short. Следовательно, спецификатор %hd отображает целое число типа short в десятичной форме, а спецификатор %ho отображает это же число в восьмеричной форме. Префиксы h и l можно использовать вместе с префиксом u для типов без знака.

```
/* print2.c -- дополнительные свойства функции printf () */
#include <stdio.h>
int main (void)
{
    unsigned int un = 3000000000; /* система с 32-битным типом int */
    short end = 200; /* и 16-битным типом short */
    long big = 65537 ;
    long long verybig = 12345678908642;
    printf("un = %u, but no %d\n", un, un) ;
    printf("end = %hd and %d\n", end, end) ;
    printf("big = %ld, but no %hd\n", big, big) ;
    printf("verybig = %lld, but no %ld\n", verybig, verybig) ;
    return 0;
}
```
">>"
```
un = 3000000000, but no -1294967296
end = 200 and 200
big = 65537, but no 1
verybig = 12345678908642, but no 1942899938
```

Этот пример демонстрирует, что использование неправильных спецификаторов может привести к неожиданным результатам. 

<mark style="background: #ABF7F7A6;">Далее отметим, что переменная end типа short отображается одинаково независимо от того, указываете вы функции printf() принадлежность end к тину short (%hd) или к типу int (спецификатор %d). Это объясняется тем, что при передаче аргумента типы short автоматически расширяется до типа int. </mark>
<mark style="background: #FF5582A6;">Здесь могут возникнуть два вопроса: почему предпринимается указанное преобразование, и для чего используется модификатор h? Ответ на первый вопрос прост: для типа int выбирался такой размер, чтобы обеспечить наиболее эффективную его обработку компьютером. Следовательно, на компьютере, в котором типы short и int имеют разные размеры, передача значения как int может осуществляться быстрее. Ответ на второй вопрос выглядит так: модификатор h можно применять, чтобы продемонстрировать, какой вид примет целое значение, будучи усеченным до типа short. 
</mark>
## СПЕЦИФИКАТОРЫ
[[Specifies C]]

## Использование символов: тип char
Тип данных char применяется для хранения символов, таких как буквы и знаки препинания, однако формально он также является целочисленным. К примеру, целое значение 65 в нем представляет прописную букву А. Таким образом, чтобы сохранить букву А, фактически нужно записать целое число 65


> [!NOTE] Стандартный код ASCII
> Cостоит из последовательности чисел от 0 до 127

### Объявление, инициализация переменных типа char
```
char response;
char grade = 'A';
```
Одиночный символ, заключенный в одиночные кавычки, представляет собой символьную константу.

```
char grade = 65;
```
В данном примере 65 имеет тип int. Но лучше применять не 65, а 'А'

### Управляющие последовательности

| Последовательность | Описание                                                         |
| ------------------ | ---------------------------------------------------------------- |
| \a                 | Предупреждение = звуковой сигнал                                 |
| \b                 | Возврат на одну позицию влево                                    |
| \f                 | Перевод страницы                                                 |
| \n                 | Новая строка                                                     |
| \r                 | Возврат каретки                                                  |
| \t                 | Горизонтальная табуляция                                         |
| \v                 | Вертикальная табуляция                                           |
| \\                 | Обратная косая черта ( \)                                        |
| \t'(без t, но с ') | Одиночная кавычка ( ' )                                          |
| \t"(тоже самое)    | Двойная кавычка (")                                              |
| \t?(тоже самое)    | Знак вопроса (?)                                                 |
| \t0oo(тоже самое)  | Восьмеричное значение (о представляет восьмеричную цифру)        |
| \xhh               | Шестнатеричное значение (h представляет шестнадцатеричную цифру) |
Управляющие последовательности, присваиваемые символьным переменным, должны быть заключены в одиночные кавычки.
```
char nerf = '\n';
```
А затем вывести переменную n e rf, что обеспечит перемещение на следующую строку на принтере или на экране монитора.

### Печатаемые символы
Для указания на то, что должен быть выведен символ, в функции printf() используется спецификатор %c. При выводе значения переменной типа char с обычным спецификатором %d будет получено целое число. Спецификатор формата %с сообщает функции p r in t f () о необходимости отобразить символ с кодовым значением, равным этому целому числу
![[Pasted image 20250406170153.png]]

```
    char ch = 'A';
    printf("Код символа %c\n",  ch);
```
`%c` — значит "символ, мать его", и `printf` не ебет — ты даёшь символ, он печатает его. Всё просто.

a.k.a Строка
```
char str[] = "Hello, bitch!";
printf("%s\n", str);  // Выводит: Hello, bitch!
```
`%s` — значит "строка", и `printf` прёт до первого `\0`. Если `\0` нет — жди SEGFAULT, придурок.

Типа ты решил, что `\0` — это для слабаков?
```
char fuckery[5] = {'H', 'e', 'l', 'l', 'o'};
for (int i = 0; i < 5; i++) {
    printf("%c", fuckery[i]);
}
printf("\n");

```
Потому что `%s` ждёт `\0`, а тут его хрен догонишь. Так что без цикла — ты просто клоун на шоу "Дебаггинг с огнетушителем".
### Со знаком или без знака?
Тип char является типом со знаком. Это значит, что переменная типа char может принимать значения из диапазона от -128 до 127. В других реализациях тип char сделан беззнаковым и может иметь значения из диапазона от 0 до 255.
язык С позволяет использовать ключевые слова signed и unsigned с типом char.  Затем, независимо от того, какими являются данные типа char по умолчанию, тип signed char будет со знаком, а тип unsigned char - без знака

### Тип Bool
Применяется для представления булевских значений, т.е. логических значений true (истина) и false (ложь).
True используется значение 1, а для представления false — значение 0, тип Bool по существу является целочисленным типом, но таким, который в принципе требует всего 1 бит памяти, поскольку этого достаточно, чтобы охватить весь диапазон от 0 до 1.

### Переносимые типы: stdint.h и inttypes.h
Это **заголовочные файлы**, которые дают тебе **переносимые типы данных**, чтобы твой код не сосал на каждом втором компиляторе или архитектуре.

Ты писал:
```
int a = 5;
```
И думал: "Ну, это ж 4 байта, да?"
Ага, щас. **На одном компе 4 байта, на другом — 2, на третьем — 8.** Потому что `int` — это как настроение у бывшей: хрен предскажешь.

`stdint.h`: Прямиком в царство ясности
Тебе нужны чёткие, блядь, гарантии? Вот они:

| Тип      | Значение                              |
| -------- | ------------------------------------- |
| int8_t   | Ровно 8 бит, знаковый (`-128..127`)\| |
| uint8_t  | 8 бит, беззнаковый (`0..255`)         |
| int16_t  | 16 бит                                |
| uint16_t | 16 бит беззнаковый                    |
| int32_t  | 32 бита                               |
| uint32_t | 32 бита беззнаковый                   |
| int64_t  | 64 бита                               |
| uint64_t | 64 бита беззнаковый                   |
Да, **всё строго**, всё как на зоне — никаких неожиданностей.
```
#include <stdint.h>

int32_t x = 1337;
uint8_t y = 255;
```
Это будет работать **одинаково** хоть на печке, хоть на суперкомпьютере.

А что за `inttypes.h`
Это типа дружок `stdint.h`, но даёт ещё и:
1. **Макросы для `printf`** — чтоб не обосраться, когда печатаешь переносимые типы.
2. **Функции для парсинга (`scanf`)** этих же типов.

```
#include <inttypes.h>

int32_t val = 1337;
printf("Val = %" PRId32 "\n", val);

```
Что за `%` `"PRId32"`?  
Это макрос, который будет **правильно работать на любой платформе**.
Если ты просто напишешь `%d`, а `int32_t` окажется `long` — всё пизда, undefined behavior уже дрочит тебе в окно.

Почему это важно?
Потому что если ты не используешь `stdint.h` и `inttypes.h`, ты буквально подписываешь контракт с дьяволом на тему:
- код у тебя будет непереносимый кусок говна;
- баги будут приходить из будущего и ебать тебя во сне;
- твоя IDE будет тебе врать, а компилятор — издеваться.

TL;DR для дегенератов:
- **`stdint.h`** — даёт **переносимые типы** (`int8_t`, `uint64_t` и прочее).
- **`inttypes.h`** — даёт макросы **для вывода и ввода** этих типов (`PRId64`, `PRIu8`, и т.д.).
- **Используй их, если не хочешь, чтобы твой код сломался на другом ПК, как ебаная жопа на морозе.**

Как в книге:
Язык C в стандарте C99 добавил **переносимые имена для целочисленных типов**, чтобы код не ломался на разных платформах.
**🔹Точные по ширине типы** (из `<stdint.h>`):
- `int32_t` — ровно 32 бита, если система это поддерживает.
- Если нет подходящего типа — такой не будет определён.

🔹 **Типы с минимальной шириной**:
- `int_least8_t` — **как минимум** 8 бит, может быть больше.
- Используются, если точная ширина недоступна.
    
🔹 **Быстродействующие типы**:
- `int_fast8_t` — самый **быстрый** доступный тип, способный хранить хотя бы 8 бит.
    
🔹 **Максимальные типы**:
- `intmax_t`, `uintmax_t` — **ебать как большие. Самые ёмкие знаковые и беззнаковые типы, какие есть на системе.
🔹 Для вывода этих типов через `printf` и `scanf`, подключай `<inttypes.h>`, который даст тебе нужные **макросы форматов** типа `PRId32` вместо е**ного угадывания `%d`, `%ld` и прочей херни.

Пиши универсальный код — пользуйся этими типами, и не завязывайся на "а вдруг у нас `int` — это 16 бит, а `long` — 32". Нахуй гадания, бери гарантированный тип и работай.

```
#include <stdio.h>
#include <stdint.h>
#include <inttypes.h>

int main ()
{

    int32_t me32; // me32 -- это 32-битная переменная со знаком
    me32 = 45933945;
    printf("Сначала предположим, что int32_t является int: ");
    printf("me32 = %d\n", me32);
    printf("Далее не будем делать никаких предположений. \n");
    printf("Вместо этого воспользуемся \"макросом\" из файла inttypes.h: ");
    printf("me32 = %" PRId32 "\n", me32);
    return 0;
}
```
## Типы float , double и long double
Разнообразные целочисленные типы нормально подходят для большинства проектов по разработке программного обеспечения. Тем не менее, ориентированные на математику и финансы программы часто оперируют числами с плавающей запятой. В языке С такие числа имеют тип float, double или long double.
Числа с плавающей запятой позволяют представлять намного больший диапазон чисел, включая десятичные дроби.

| Число         | Научн.форма | Экспоненциальная форма записи |
| ------------- | ----------- | ----------------------------- |
| 1 000 000 000 | 1.0*10^9    | 1.0e9                         |
| 123 000       | 1.23*10^5   | 1.23e5                        |
| 322,56        | 3.2256*10^3 | 3.2256e2                      |
| 0,000056      | 5.6*10^-5   | 5.6e-5                        |
 `float` — тупо минималка, но рабочая:
- **6 значащих цифр** — типа может точно держать `33.3333`, дальше будет шиза.
- **Диапазон**: от **10⁻⁷ до 10⁷**, т.е. если ты не работаешь с чёрными дырами — пойдёт.
- **32 бита**:
    - 8 бит — ебаная экспонента (с её знаком).
    - 24 бита — мантисса (это та часть, где реально хранится значение).
    - Это всё... хреново, если надо точность.
```
float noah, johah;
float planck = 6.66e-32;
```

 `double` — в два раза мощнее:
- **10 значащих цифр минимум**, а обычно тебе дают аж **13** — хватит даже для подсчёта твоих провалов по жизни.
- **64 бита**:
    - Может либо:
        - увеличить **мантиссу** (=> точность растёт, меньше ошибок округления),
        - либо расширить **экспоненту** (=> можно хранить числа типа массы Солнца и госдолга США).
- В общем, **double — это float на стероидах**.
```
double trouble;
```

`long double` — если ты реально повернут на точности:
- Гарантируется только одно: **он не хуже double**, а может быть и ебически лучше — зависит от компилятора, системы и твоего везения.
- В реальности — может занимать **80, 96, 128 бит** и быть просто ебанутым по точности.
```
long double gnp;
```

<mark style="background: #FF5582A6;">TL;DR - **Too Long; Didn't Read"** — короче, **"слишком дохуя текста, дай суть!"**:</mark>

| Тип         | Размер | Значащих цифр | Для кого                                               |
| ----------- | ------ | ------------- | ------------------------------------------------------ |
| float       | 32     | >=6           | Для студента, который не знает, как устроен float      |
| double      | 64     | >=10(до 13)   | Для нормальных людей                                   |
| long double | 80+    | >= 13+        | Для тех, кто верит в магию π и число e с 1000 знаками. |

%% IEEE 754 %%

 Поведение по умолчанию:=
- **`2.3` → `double`**  
    Без всяких суффиксов любое число с плавающей точкой — **тип `double`**. Жри это и не ной.

 Суффикс `f` или `F` → `float`:
- Пример: `2.3f`, `9.11E9F`  
    Говорит компилятору: **"Не выпендривайся, это `float`, а не `double`."**  
    Полезно, если ты хочешь экономить память, быть нищебродом и ловить больше багов от потери точности.

F, который заставляет компилятор трактовать константу с плавающей запятой
Начиная со стандарта С99, в языке С имеется новый формат для выражения констант с илавающей запятой. В нем применяется шестнадцатеричный префикс (Ох или ОХ) с шестнадцатеричными цифрами, р или Р вместо е или Е и экспонента, которая является степенью 2, а не 10. Такое число может выглядеть следующим образом:

```
0xa.lfp10
```

a - это 10 в шестнадцатеричной системе, .lf - 1/16 плюс 15/256; f - это 15 в шестнадцатеричной системе; а p10 — это 2^10, или 1024. В результате полное значение равно (10 + 1/16 + 15/256) * 1024, или 10364,0 в десятичной форме записи

## Вывод значений с плавающей запятой
> [!NOTE]
> АХАХА, ну вот мы и добрались до ебучей **`printf()`**, этой дикой шлюхи, которая делает вид, будто умеет красиво печатать числа, но всё время подкидывает тебе сюрпризы.
### **%f**
- Печатает в **обычном десятичном формате**.
- Работает с `float` и `double`.  
    → Потому что **`float` в любом случае ебашится в `double`**, когда ты суёшь его в `printf()`.
    Пример:
```
printf("%f", 3.14);  // → 3.140000
```

### **%e** или **%E**

- Вывод в **экспоненциальной форме** — как будто ты ученый в лаборатории, а не студент, который скопировал код с StackOverflow.
```
%e -> 3.140000e+00
%e -> 3.140000e+00
```

### **%a** или **%A** (если поддерживается)

- Шестнадцатеричный вывод типа:
```
printf("%a", 3.14);  // → 0x1.91eb86p+1
```
## Для `long double` нужен **%Lf**, **%Le**, **%La**:

- `%Lf` → десятичный
- `%Le` → экспоненциальный
- `%La` → шестнадцатеричный, если не откажется скомпилироваться
```

```


> [!NOTE] Но какого хера `float` и `double` используют одни и те же спецификаторы?
> Потому что C — это **старый ублюдок**, в котором при передаче аргументов в функцию без строго заданного прототипа (а `printf` — именно такая), **`float` автоматически кастится в `double`**.
> Это называется **default argument promotion**, и тебе придётся с этим мириться. Либо страдать, как твой дебаггер.

TL;DR:

| Тип          | Формат | Пример     |
| ------------ | ------ | ---------- |
| float/double | %f     | Обыч.число |
| float/double | %e/%E  | Экспонента |
| float/double | %a/%A  | HEX        |
| long double  | %Lf    | Десятичное |
| long double  | %Le    | Экспонента |
| long double  | %La    | HEX        |

```
#include <stdio.h>

int main(void)
{
    float aboat = 32000.0;
    double abet = 2.14e9;
    long double dip = 5.32e-5;
    printf("%f может быть записано как %e\n", aboat, aboat);
    printf ("И его %a в шестнадцатеричной, представляющей степени 2, форме записи\n", aboat);
    printf("%f может быть записано как %e\n", abet, abet);
    printf("%Lf может быть записано как %Le\n", dip, dip);
    return 0;
}
```

> 32000.000000 может быть записано как 3.200000e+004
И его 0x1.f40000p+14 в шестнадцатеричной, представляющей степени 2, форме записи
2140000000.000000 может быть записано как 2.140000e+009
-1950228512509697500000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.000000 может быть записано как 2.725002e+002

### Переполнение и потеря значимости в операциях с плавающей запятой
```
int main(void)
{
   float toobig = 3.4e38 * 100.0f; // слишком велико для float
    printf("toobig = %e\n", toobig); // вывод в формате float
    return 0;
}
```
> toobig = 1.#INF00e+000

Что произойдет? Это пример переполненения, когда в результате вычислений получается слишком большое число, чтобы его можно было правильно представить.

Что тут происходит:
- `3.4e38` — это уже **на грани дозволенного** для `float`.
- `* 100.0f` — и ты **перешёл границу в ад**, потому что итоговое значение уже не влезает в `float`.
Результат:
- **Переполнение** типа `float`.
   - В итоге `toobig` получает значение **+∞** (положительная бесконечность).

Микроскопическое деление:
Представим, ты хочешь делить и так уже минимальное число `float` на 2.
Вот тут начинается настоящее **дно в подвале точности**:
- Число уже на минимуме экспоненты (степени).
- Делишь на 2? Экспоненту уже **нельзя уменьшить**, поэтому происходит **сдвиг мантиссы** вправо.
- Это даёт тебе **субнормальное число**: оно **меньше, чем может быть представлено "нормальным" float'ом**, и **теряет точность**.
```
float smallest = 1.4e-45; // или FLT_MIN, или ещё меньше
float half = smallest / 2; // → субнормальное значение
```
>half = 0.000000e+000

🧟‍♂️ Что такое субнормальные числа?
- Значения, которые **слишком малы**, чтобы вписаться в нормальный `float`, но всё ещё **ненулевые**.
- Поддерживаются не на всех архитектурах.
- **Дико тормозят**, если у тебя железо их не любит.
- Считай, это **инвалидность чисел** — вроде живое, но нормальным уже не назвать.

💩 А что за NaN?
```
float x = sqrtf(-1.0f); // Или asin(10.0f)
printf("%f\n", x); // → nan

```
>-1.#IND00

Возникает, когда ты:
- Делишь ноль на ноль
- Пытаешься взять логарифм от отрицательного
- Пихаешь в `asin()` число больше 1
- Или вызываешь `tan(PI/2)` и удивляешься


## Комплексные и мнимые типы
нахуй не нужны

## Сводка: базовые типы данных
### Ключевые слова
Базовые типы данных устанавливаются с применением 11 ключевых слов: int, long, short, unsigned,char, float, double,signed, Bool, Complex И Imaginary.
### Целые числа с о знаком
Они могут иметь как положительные, так и отрицательные значения
int — базовый целочисленный тип в заданной системе. Язык С гарантирует для int не менее 16 битов. 
• short или short int — максимальное целое число типа short не превосходит наибольшего целочисленного значения типа int. Язык С гарантирует для short не менее 16 битов. 
• long или long int — может хранить целое число, которое, как минимум, не меньше наибольшего числа типа int или больше его. Язык С гарантирует для long не менее 32 битов. 
• long long или long long int — этоттип может быть целым числом, которое, как минимум, не меньше наибольшего числа типа long, а, возможно, и больше его. Для long long гарантируются не менее 64 битов.
Обычно тип long имеет большую длину, чем short, а длина типа int совпадает с длиной одного из этих типов. Н
### Целые без знака
Такие типы хранят только нулевое или положительные значения. Это расширяет диапазон до большего возможного положительного числа. Указывайте ключевое слово unsigned перед желаемым типом: unsigned int, unsigned long, unsigned short. Одиночное ключевое unsigned означает то же, что и unsigned int.
### Символы
Ими являются типографские символы, такие как а , & и +. По определению тип char для представления символа использует 1 байт памяти. Исторически сложилось так, что байт символа чаще всего имеет длину 8 битов, но он может быть длиной 16 битов или больше, если это необходимо для представления базового набора символов.
- char — ключевое слово для этого типа. В одних реализациях применяется тип char со знаком, в других он без знака. Язык С позволяет использовать ключевые слова signed и unsigned для указания нужной формы.
### Булевские значения
Булевский тип представляет значения true (истина) и false (ложь); в языке С для представления true применяется 1, а для представления false — 0.
Bool — ключевое слово для этого типа. Он является типом int без знака и должен быть настолько большим, чтобы обеспечить хранение значений из диапазона от 0 до 1
### Вещественные числа с плавающей запятой
• float — базовый тип данных с плавающей запятой в системе; он может представлять, по меньшей мере, шесть значащих цифр с заданной точностью. 
• double — (возможно) большая единица для хранения чисел с плавающей запятой. Этот тип может разрешать большее количество значащих цифр (минимум 10, но обычно больше) и, возможно, большие значения показателя степени, чем тип float. 
• long double — (возможно) еще большая единица для хранения чисел с плавающей запятой. Этот тип может разрешать большее количество значащих цифр и, возможно, большие значения показателя степени, чем тип double.

### Сводка: объявление простой переменной
1. Выберите необходимый тип данных. 
2. Выберите имя для переменной, включающее разрешенные символы. 
3. Применяйте следующий формат для оператора объявления: 
спецификатор-типа имя-переменной;
Компонент спецификатор-типа образуется из одного или большего количества ключевых слов для типов; вот примеры объявлений: 
int erest; 
unsigned short cash;
 4. Вы можете объявлять сразу несколько переменных одного и того же типа, разделяя имена переменных запятыми. Например: char ch, init, ans; 
 5. Вы можете инициализировать переменную в операторе объявления:  float mass = 6.0Е24;

## Размеры типов
Какие размеры тип о в используются в вашей системе? Чтобы выяснить это, попробуйте выполнить программу
```
int main(void)
{
    /* В стандарте с99 для размеров предусмотрен спецификатор %zd */
    printf("Тип int имеет размер %zd байт(ов).\n", sizeof(int));
    printf("Тип char имеет размер %zd байт(ов).\n", sizeof(char));
    printf("Тип long имеет размер %zd байт(ов). \n", sizeof(long));
    printf("Тип long long имеет размер %zd байт(ов). \n", sizeof(long long));
    printf("Tип double имеет размер %zd байт(ов) .\n", sizeof (double) ) ;
    printf("Тип long double имеет размер %zd байт(ов).\n",
    sizeof(long double)) ;  
    return 0;
}
```
В языке С имеется встроенная операция sizeof, которая возвращает размер типа в байтах. Для такого применения sizeof предоставляется спецификатор **%zd**
 Кстати, в нескольких последних строках обратите внимание на то, что оператор printf() можно разнести на две строки. Его можно разделять на большее количество частей при условии, что разрыв не происходит внутри раздела, заключенного в кавычки, или в середине слова.
 ```
 int main(void)
{
    printf("Введи ваш возраст: ");
    int32_t age;;
    scanf("%" SCNd32, &age);
    printf("Ваш возраст: %" PRId32, age);
    printf("\nРазмер вашего возраста в битах: %zd\n", sizeof(int32_t) * 8);
    return 0;
}
```
## Сброс буфера вывода
Функции типа `printf()` пишут не **на экран напрямую**, а сначала **в буфер** — типа такая временная заначка, где текст тусуется, пока системе не вздумается. 
Но иногда тебе **нужно сразу**, без задержек — типа ты делаешь:
```
printf("Введите имя: ");
```

💣 Решение: **`fflush(stdout);`**
```
printf("Введите имя: ");
fflush(stdout);  // вот теперь точно покажет, сцука
```
Это прямой **пинок под зад**: "Очисть буфер и вылей всё, что накопилось, на экран!"
fflush(stdout); после printf гарантирует, что текст приглашения будет виден пользователю до того, как программа начнет ждать ввода.
### 🧻 Когда это нужно?
- Когда ты просишь ввод (`scanf`, `fgets`) после `printf`.
- Когда stdout направлен не в терминал, а в файл/канал/жопу.
- Когда хочешь **гарантировать порядок вывода**.
- Когда ловишь баги и хочешь, чтобы сообщения **отображались в нужный момент**, а не “когда-нибудь потом”.

### ⚠️ Что НЕ стоит делать
Не вздумай писать `fflush(stdin);` — **это undefined behavior, ёпт!** Если ты делаешь так:
```
fflush(stdin); // Молишься, чтобы не взорвалось
```
...то стандарт C идёт к тебе в гости и **срет тебе в тапки**.  
Это не очищает ввод, это вызывает анальное страдание у компиляторов.

🧼 Если хочешь очистить **ввод** — делай правильно:
```
int c;
while ((c = getchar()) != '\n' && c != EOF);

```

```
int main()
{
   char name[50];
    printf("Введи своё жалкое имя: ");
   fflush(stdin);
    scanf("%49s", name);
    printf("Пидар, тебя зовут: %s", name);
    return 0;
}
```

<mark style="background: #FF5582A6;">ЛУЧШЕ ИСПОЛЬЗОВАТЬ "\n" - ЗДРАВЫЙ ПАЦАН</mark>
### 👊 TL;DR:
- `fflush(stdout);` — **сбрасывает буфер вывода**. Показывает текст сразу.
- Нужен, чтобы не сидеть, как идиот, ожидая вывода.
- Не еби мозг компилятору с `fflush(stdin)` — только для `stdout`, `stderr`, `files`.
# Символьные строки и форматированный ввод-вывод
```
#include <stdio.h>
#include <string.h>
// #include <stdint.h>
// #include <inttypes.h>
#define FOOT 2.2046
int main()
{
    double weight, weight2;
    int age, letters;
    char name[40];
 
	printf("Введите ваше имя: ");
    scanf("%39s", name);

    printf("Введите ваш вес в КГ: ");
    
    scanf("%lf", &weight);
    printf("Введите ваш возраст: ");
    
    scanf("%d", &age);
    printf("\n");
  
    weight2 = weight * FOOT;
   
	printf("Ваше имя: %s, состоящее из: %zu букв,", name, strlen(name));
    printf(" для него мы заняли: %zd байт.\n", sizeof(name));
    printf("Ваш вес в КГ: %.2lf, а в фунтах это будет: %.2lf \n", weight, weight2);
    printf("Ваш возраст: %d, для которого мы заняли: %zd", age, sizeof(age));
    printf(" байта\n");
    return 0;
}
```

>Ваше имя: Аллах, состоящее из: 10 букв
Ваш вес в КГ: 1488.000, а в фунтах это будет: 3280.445
Для него мы знаняли: 320 бит
Ваш возраст: 1488, для которого мы заняли: 32 битт

**НУЖЕН ФИКС**

## Введение в символьные строки
Символъния строка - это последовательность из одного или большего количества символов. Двойные кавычки не являются частью строки. Они сообщают компилятору, что внутри них содержится строка
## Массив типа char и нулевой символ
В языке С не существует какого-то специального типа для строковых переменных. Вместо этого для строк применяются массивы типа char. Символы в строке хранятся в смежных ячейках памяти, по одному символу на ячейку, а массив состоит из смежных ячеек памяти, так что строка размещается в массиве вполне естественным образом
![[Pasted image 20250407230811.png]]
В последней позиции массива находится символ \0. Он представляет собой нулевой символ, который в языке С служит для пометки конца строки. Нулевой символ - это не цифра ноль, а непечатаемый символ, кодовое значение которого в кодировке ASCII равно 0. Строки в С всегда сохраняются с завершающим нулевым символом.
Присутствие нулевого символа означает, что массив должен иметь, по крайней мере, на одну ячейку больше, чем количество символов, которые требуется сохранить. Таким об разом, когда приведенная программа сообщает, что она располагает 40 байтами для стро ки, это означает, что она может хршпить вплоть до 39 символов плюс нулевой символ.
Что же такое массив? Массив можно представить как несколько ячеек памяти, расположенных подряд. Другими словами массив - но упорядоченная последовательность элементов данных одного типа:
```
char name[40];
```
Квадратные скобки после имени name идентифицируют его как массив.
![[Pasted image 20250407231026.png]]


## Использование строк(char)
```
#include <stdio.h>
#define PIDOR "Аллах пидар, кстати"
  
int main()
{
    char name[12];
    scanf("%11s", name);
    printf("%s. %s\n", name, PIDOR);
    return 0;
}
```
Спецификатор %s сообщает функции printf() о необходимости вывода строки. Он встречается дважды, т.к. программа выводит две строки: одна хранится в массиве name, а другая представлена PIDOR.
>Аллах. Аллах пидар, кстати

Если в массив Char забубенить имя  и фамилию
```
char name[40];
scanf("%49s", name);
И вывести: Пизда Ивановна
```
То, она останавливает чтение на первом встреченном пробельном символе (символе пробела, табуляции или новой строки).  считывание для массива name прекращается, когда появляется символ пробела между словами “Пизда” и “Ивановна”. 
В языке С доступны другие функции ввода данных, такие как fgets(), поддерживающая общие строки

### fgets()

## Функция strlen()
Функция strlen() возвращает длину строки в символах.
Поскольку для размещения одного символа требуется один байт, можно было бы предположить, что применительно к строке sizeof и stlen() дадут один и тот же результат, однако это не так.

```
#include <stdio.h>
#include <string.h>
// #include <stdint.h>
// #include <inttypes.h>
  
#define POUNDS 2.2046
  
int main()
{
    char name[20];
    unsigned short age;
    double weight, weighttopounds;
    printf("Введите ваш возраст: ");
    scanf("%hd", &age);
    printf("Введите ваше имя: ");
    scanf("%39s", name);
    printf("Введите ваш вес в КГ: ");
    scanf("%lf", &weight);
    weighttopounds = weight * POUNDS;
    printf("Ваше имя: %s\n", name);
    printf("Ваш возраст: %d\n", age);
    printf("Ваш вес в КГ: %.2lf, а в фунтах: %.2lf\n", weight, weighttopounds);
  
    printf("Ваше имя содержит: %zd символов\n", strlen(name)/2);
    printf("И занимает: %zd бит \n", sizeof(name));
  
    return 0;

}
```
Массив name имеет 20 ячеек памяти, и именно об этом сообщает операция sizeof. Name необходимы только первые 10 ячеек, и об этом информирует функция strlen().Однако для размещения имени Васёк необходимы только первые 10 ячеек, и об этом информирует функция strlen()
**STRLEN считает байты, по этому здесь будет 10, заместо 5, т.к в UTF-8 Русские буквы содержат 2 знака, а не один.**  
![[Pasted image 20250409122837.png]]


## Константы и препроцессор с
Лучше использовать цифры, вместо букв. Для большего понимая. Пример:
```
square = storona * pi
```
и 
```
square = storona * 3,141592
```
Второй вариант более читаемый и понятный.

Либо
```
#define PI 3,141592
square = storona * PI
```

Директиву #define можно использовать также для объявления символьных и строковых констант. Достаточно указать одиночные кавычки для символьных и двойные кавычки для сфюковых констант.

```
#define ВЕЕР '\а'
#define ТЕЕ 'Т'
#define ESC '\033'
#define OOPS "Теперь вы сделали это!"
```
## Модификатор const
#DEFINE, раньше был const int MONTHS, но его нельзя было по

Заголовочные файлы limits.h и float.h содержат подробную информацию об ограничениях размеров, соответственно, целочисленных типов и типов сплавающей запятой. В каждом файле определена последовательность символических констант, которые применяются к реализации.

![[Pasted image 20250409135822.png]] ![[Pasted image 20250409135830.png]]
Анлагично , в файле float.h определены такие константы, как FLT_DIG и DBL_DIG, которые представляют количество значащих цифр, поддерживаемое типами float и double.
![[Pasted image 20250409135816.png]]

```
//defines.c — использует именованные константы из файла limit.h и тип float.
#include <stdio.h>
#include <limits.h> // пределы для целых чисел
#include <float.h> // пределы для чисел с плавающей запятой
int main()
{
    printf("Некоторые пределы чисел для данной системы:\n");
    printf("Наибольшее значение типа int: %d\n", INT_MAX) ;
    printf("Наименьшее значение типа long long: %lld\n", LLONG_MIN);
    printf("B данной системе один байт = %d битов.\n", CHAR_BIT);
    printf ("Наибольшее значение типа doUie: %e\n", DBL_MAX);
    printf("Наименьшее нормализованное значение типа float: %e\n", FLT_MIN);
    printf( "Toчнocть значений типа float = %d знаков^", FLT_DIG) ;
    printf( "Разница между 1.00 и минимальным значением float, которое больше 1.00 = %e\n", FLT_EPSILON);
    return 0;
}
```


# Спецификаторы преобразования вывода

| Спецификатор | Тип          | Пример | Вывод                       |
| ------------ | ------------ | ------ | --------------------------- |
| %d           | int          | 123    | Десятичное                  |
| %i           | int          | 123    | То же, что `%d`             |
| %u           | unsigned int | 123    | Без знака                   |
| %x           | unsigned int | 255    | hex (нижний регистр, `ff`)  |
| %X           | unsigned int | 255    | hex (верхний регистр, `FF`) |
| %o           | unsigned int | 8      | восьмеричное (`10`)         |
**Символы и строки**

| Спецификатор | Тип   | Пример  | Вывод |
| ------------ | ----- | ------- | ----- |
| %c           | char  | 'A'     | A     |
| %s           | char* | "hello" | hello |
**Числа с плавающей запятой**

| Спецификатор | Тип          | Пример | Вывод                                 |
| ------------ | ------------ | ------ | ------------------------------------- |
| %f           | float/double | 3.14   | Обычное десятичное (3.140000)         |
| %.2f         | float/double | 3.14   | С точностью (3.14)                    |
| %e           | float/double | 3.14   | Экспоненциальная форма (3.140000e+00) |
| %E           | float/double | 3.14   | То же, но с `E`                       |
| %g           | float/double | 3.14   | Автоматически `%f` или `%e`           |
| %a           | float/double | 3.14   | hex float                             |
**Модификаторы размера типа:**

| Спецификатор | Тип            | Комментарий          |
| ------------ | -------------- | -------------------- |
| %hhd         | signed char    | Маленькие числа      |
| %hd          | short          |                      |
| %hu          | unsigned short |                      |
| %ld          | long           |                      |
| %lld         | long long      |                      |
| %zd          | size_t         | Для указателей длину |
| %Lf          | long double    | Чистая боль          |
|              |                |                      |
**Указатель(адрес)**

| Спецификатор | Тип              | Комментарий |
| ------------ | ---------------- | ----------- |
| %p           | Указатель(адрес) |             |


❌ Чего **НЕ** делать:
- `%lf` в `printf()`? **НЕ НУЖНО** — `float` всегда промоутится до `double`.
- `%f` для `float`? **ДА**, нормально, жри.
- `%s` без `\0`? **Подпишись на свою смерть.**


Пример:
```
#include <stdio.h>
#define PI 3.141593
int main (void)
{
    int number = 7;
    float pies = 12.75;
    int cost = 7800;
    printf("%d участников соревнований съели %f пирожков с вишнями.\n", number, pies);
    printf("Значение pi равно %f.\n", PI);
    printf("До свидания! Ваше искусство слишком дорого обходится,\n");
    printf("%c%d\n", '$', 2 * cost);
    return 0;
}
```

**Так же выражение можно вывести в квадратных скобках:**
```
    printf("[%2d] участников соревнований съели %f пирожков с вишнями.\n", number, pies);
```
> [ 7] участников соревнований съели 12.750000 пирожков с вишнями.

### Вывод длинных строк
Иногда операторы printf () оказываются слишком длинными , чтобы уместиться в одной строке файла исходного кода. оператор можно разнести на несколько строк, при условии, что разрывы строк размещаются строго между элементами.
```
printf("Функция printf() вывела %d символов.\n", 
		rv);
```
В данном случае строка разбита между элементами запятой и rv. Чтобы показать читателю кода, что строка имеет продолжение, применяется оступ.

Однако нельзя разрывать строку внутри кавычек.
```
рrintf("Функция printf() вывела %d 
		символов.\n", rv) ;
```
В таком случае компилятор cообщит об использовании недопустимого символа в строковой константе.

**Когда требуется разбить строку, для этого существуют три возможности:**
```
#include <stdio.h>
int main(void)
{
    printf("Вот один из способов вывода ");
    printf("длинной строки.\n");
    printf("Вот второй способ вывода \
    длинной строки.\n");
    printf("A вот самый новый способ вывода "
    "длинной строки.\n"); /* ANSI С */
    return 0;
    }
```

### Использование функции scanf()
Функция scanf() позволяет помещать в строку формата обычные символы
```
scanf("%d,%d", &n, &m);
```
Функция scanf() интерпретирует эту сроку так, что вам придется набрать число, затем запятую и, наконец, второе число.
> 88, 121

Модификатор * в функциях printf ( ) и scanf()
**В `printf()`**: Модификатор `*` используется для динамического указания ширины поля, которое нужно использовать для вывода. То есть, вместо того чтобы задавать фиксированную ширину вывода напрямую, вы можете передать значение через аргументы функции
```
int width = 10;
printf("%*d\n", width, 42);  // Ширина поля будет 10
```
**В `scanf()`**: Модификатор `*` используется для пропуска считывания значения. Когда вы используете `*` перед типом данных, функция `scanf()` игнорирует ввод для этого параметра, то есть оно просто пропускается, но остальные значения считываются как обычно.
```
int a, b;
scanf("%d *%d", &a, &b);  // Пропускаем одно число
```
В этом примере, если в строке ввода будет два числа, то первое число будет считано в переменную `a`, а второе игнорируется из-за использования `*`, и только третье число будет записано в переменную `b`. Указывает программе н а необходимость пропуска двух целых чисел и копирования третьего целого числа в переменную n

```
#include <stdio.h>

int main() {
    int width = 10;
    int number = 42;
    
    // %*d позволяет задать ширину поля для целого числа
    printf("Number with dynamic width: %*d\n", width, number);
    
    return 0;
}
```
`%*d` указывает, что ширина поля для целого числа будет задана динамически.
Мы передаем значение переменной `width` (в данном случае это 10) перед числом, которое нужно вывести (`number`).
> Number with dynamic width:         42

```
#include <stdio.h>

int main()
{
    char name[50];
    int width, widthforname;
    printf("Введите ширину поля: ");
    scanf("%d", &width);
  
    printf("Введите ширину поля для имени: ");
    scanf("%d", &widthforname);
  
    printf("Введите ваше имя: ");
    scanf("%49s", name);
  
    printf("%*sПривет, \"%*s\"\n", width, "", widthforname, name);
  
}
```

`%.*f` указывает, что точность для вывода числа с плавающей точкой будет задана динамически.
```
#include <stdio.h>

int main() {
    int precision = 3;
    double value = 3.141592653589793;
    
    // %.*f позволяет задать точность для числа с плавающей точкой
    printf("Value with dynamic precision: %.*f\n", precision, value);
    
    return 0;
}

```
Переменная `precision` передается в функцию `printf()`, чтобы указать количество знаков после запятой.

#  Глава 5: Операции, выражения и операторы
## Введение в циклы
```
#include <stdio.h>
#define ADJUST 7.31 // константа 2
int main (void) 
{
    const double SCALE = 0.333; // константа 2
    double shoe, foot;
    printf("Размер обуви (^мужской) длина ступни\n");
    shoe = 3.0;
    while (shoe < 18.5)
{
    foot = SCALE * shoe + ADJUST;
    printf("%10.lf %20.2f даймов\n", shoe, foot);
    shoe = shoe + 1.0;
}
printf("Если обувь подходит, носите ее.\n");
return 0;
}
```
Выполняется проверка того, принимает ли условие в круглых скобках значение true.
Переменная shoe инициализирована значением З.0,  меньше чем 18.5. Поэтому условие равно **true** и переходит на следующий оператор, который преобразует размер в дюймы . Затем программа выводит результат. Следующий оператор увеличивает значение shoe на 1.0.
```
shoe = shoe + 1.0;
```
Как только значение shoe становится false, программа заканчивает выполнение 
# Фундаментальные операции
знак = не означает “равно".  Вместо этого им обозначается операция присваивания значения. 
```
bmw = 2000;
```
Оператор присваивает 2000  переменной bmw.

в С был добавлен термин **модифицируемое l-значение** для идентификации объекта , чье значение может изменяться.
Термин **r-значение** относится к величинам , которые могут быть присвоены модифи­цируемым l-значениям , но которые сами не являются  l-значениями:
- r-значении происходит от слова “right ” — “правая часть ”
- R-значениями могут быть константы, переменные или любое другое выражение, которое в результате даёт значение.

```
bmw = 2002;
```
bmw = l-знач., а 2002 = r-знач. 

```
int ex;
int why;
int zee; 
const int TWO = 2;
why = 42;
zee = why;
ex =TWO * (why + zee);
```
ex, why, zee - модифицируемые l-знач. Они могут использоваться слева или справа от символа операции присваивания. 
TWO - не модифицир. l-знач., оно может указываться только в правой части. 
42 - r-знач. 

Вырисовывается подходящий термин для того, что мы называем "элементом" (примером может служить фраза "элемент слева от знака =") - операнд. Операнд - это то, чем оперируют операции. 

Многие языки программирования не разрешают тройное присваивание значений, сделанного в этой программе, но в С это считается обычным делом:
```
cheeta = drita = pizza = 1488;
```


## Операция sizeof И тип size_t
Вспомним, что **sizeof** - *она возвращает размер своего операнда в байтах.* 
```
sizeof(int);        // обычно 4
sizeof(char);       // всегда 1, потому что 1 байт
sizeof(double);     // обычно 8
sizeof(arr);        // размер массива в байтах
sizeof(*ptr);       // размер того, на что указывает указатель
```
Только не забудь — `sizeof` **не вызывает код**. Он вычисляется на этапе компиляции. То есть если ты туда пихнёшь функцию, её **не вызовет**.

`size_t` — тип без соплей
Это просто **тип без знака**, используемый для размеров, индексов, и всего того, что не должно быть отрицательным. По факту, это просто синоним для какого-нибудь `unsigned int` или `unsigned long` в зависимости от архитектуры.
```
#include <stdio.h>
int main ()
{
	int n = 0;
	size_t intsize;
	intsize = sizeof (int)
	printf("n = %d, n состоит из %zd байтов; все значения int имеют %zd байтов. \n", n, sizeof n, intsize );
}
```
> n = 0, n состоит из 4 байтов; все значения int имеют 4 байтов.

Почему использовать `size_t`, а не `int`?
Потому что `size_t` — **тот тип, который возвращает `sizeof`**. Он гарантированно может вместить в себя любой размер объекта в памяти.

```
int n = 0;
```
Ты создаёшь **переменную `n` типа `int`**, присваивая ей значение 0. Просто, чтоб потом было что напечатать. Это ничего не делает сверхъестественного, просто ебаный ноль лежит себе.

```
size_t intsize;

```
`intsize` — переменная типа `size_t`. Это такой **беззнаковый тип**, который используется **для хранения размеров объектов**. Тип возвращается оператором `sizeof`. Почему `size_t`? Потому что всякие ёбаные `int` могут не влезть, если ты решишь посчитать размер 10-гигового массива, долбоёб.

```
intsize = sizeof (int);

```
`sizeof(int)` вернёт **размер типа `int` в байтах**, и ты сохраняешь это в `intsize`. Обычно это будет **4 байта**, но может отличаться в зависимости от платформы. Например, на 16-битном старье `int` может быть 2 байта, на 64-битном — чаще 4.

**`sizeof`** нужен, чтобы узнать эти размеры? **`size_t`** же ты используешь для работы с ними. Это не "или-или", это **комплекс!** Без **`sizeof`** и **`size_t`** ты бы не знал, что вообще с памятью происходит.

А, ну если ты хочешь вывести это **чудо** на экран, то тебе нужно использовать **`printf`** с правильным форматом. Для **`size_t`** используется спецификатор **`%zu`**, не путай с **`%d`**!
```
#include <stdio.h>
int main()
{
    size_t intsize = sizeof(int);  // Размер типа int в байтах
    // Выводим размер переменной intsize
    printf("Размер типа int в байтах: %zu\n", intsize);
    return 0;
}
```

## Typedef
 Тип `typedef` в языке C используется для создания новых типов данных или псевдонимов для уже существующих типов. Например, можно использовать `typedef` для сокращения сложных типов данных или создания алиасов для типов данных, чтобы облегчить их использование
 ```
 typedef существующий_тип новый_тип;

```
Создание псевдонима для типа:
```
typedef unsigned int uint;
uint x = 10;  // uint теперь синоним для unsigned int
```
Для структур:
```
typedef struct {
    int x;
    int y;
} Point;

Point p1;  // Теперь можно использовать Point вместо struct

```
Для указателей:
```
typedef int* int_ptr;

int_ptr ptr;  // int_ptr - это указатель на int

```
`typedef` не создает новый тип данных в плане системы типов — он просто создает псевдоним для уже существующего типа.

## Выражения и операторы
Операторы формируют базовые шаги программы на С, и большинство операторов построено на основе выражений. 
Выражение состоит из комбинации операций и операндов(опе­ранд — это то , над чем выполняется операция.) Простейшим выражением является отдельный операнд , и он может служить отправной точкой для построения более сложных выражений .
```
4
-6
4+21
a*(b+c/d)/20
q = 5*2
x = ++q % 3
q > 3
```
Операнды могут быть константы, переменные и их сочетания. 

Важное свойство языка С заключается в том , что каждое **выражение** имеет значение. Чтобы найти это значение , нужно выполнить операции в порядке , определенном приоритетами операций.

**Операторы** служат основными строительными блоками программы. **Программа** - последовательность операторов с необходимыми знаками пунктуации. Оператор представляет собой завершенную инструкцию для компьютера. **Операторы распознаются по наличию точки с запятой**
```
legs = 4 <- выражение
legs = 4; <- Оператор
```

## составные операторы (блоки)
**Составной оператор** - два или большее кол-во операторов, сгруппированных вместе путём помещения их в фигурные скобки; так называют **блоком**
```
// #1
index = 0;
while (index++ < 10)
	sam = 10 * index + 2;
print("sam = %d\n", sam);
// #2
inddex = 0;
while (index++ < 10)
{
	sam = 10 * index + 2;
	printf("sam = %d\n", sam);
}
```
Внутри #1 в цикл while включен только оператор присваивания. В отсутствие фигурных скобок область действия оператора while распространяется от ключевого слова while до следующей точки с запятой. Функция printf() вызывается только один раз — по завершении цикла.

В #2 наличие фигурных скобок гарантирует, что оба оператора являются частью цикла while, а функция printf() вызывается при каждом выполнении цикла.
![[Pasted image 20250412192738.png]]
### Операция приведения
**Вы всегда должны избегать автоматического преобразования типов.**
```
mice = 1.6 + 1.7;
mice = (int) 1.6 + (int) 1.7;
```
В первой строке применяется автоматическое преобразование типов. Всё суммируется, усекается, чтобы соответствовать типу int.
Во второй строке числа 1.6 и 1.7 преобразуется в целочисленный вид, в результата присваевается 1+1, или 2. 
**НИ ОДНА ИЗ ЭТИ ФОРМ НЕ СЧИТАЕТСЯ ПРАВИЛЬНОЙ, НЕОБХОДИМО УЧИТЫВАТЬ КОНТЕКСТ. ЛУЧШЕ ЗАРАНЕЕ УКАЗАТЬ ТИП ДАННЫХ, БЕЗ ЭТИХ ДРОЧЕК:**
```
int mice = 1.6 + 1.7
```

# ГЛАВА 6 Управляющие операторы С: циклы
## while
Цикл while — это условный цикл, использующий входное условие (предусловие). Цикл называется “условным”, поскольку выполнение его операторной части зависит от условия, описанного условным выражением, таким как ( index < 5). Это выражение представляет собой предисловие, поскольку оно должно быть удовлетворено, прежде чем произойдет вход в тело цикла.
==Оператор while создает цикл, который повторяется до тех пор, пока проверочное выражение не станет ложным, или нулевым. Оператор while представляет собой цикл с предусловием; это значит, что решение относительно очередной итерации цикла принимается перед проходом. Следовательно, вполне возможно, что цикл вообще не будет выполнен. Операторная часть цикла может быть простым или составным оператором.==
```
#include <stdio.h>
  
int main()
{
    double num, sum;
    int choice = 0;
    printf("Введите первое число: ");
    choice = scanf("%lf", &num);
  
    while (choice == 1)
    {
        sum+=num;
        printf("Введите следущие числа для сложения\n(Для выхода используйте q): ");
        choice = scanf("%lf", &num);
    }
    printf("Сумма: %.2lf", sum);
    return 0;
}
```
Условием проверки этого цикла является следующее выражение:
```
while (choice == 1)
```
На каждой итерации в цикле текущее значение num добавляется к значению переменной sum, так что sum хранит промежуточную сумму. Когда переменная status получит значение, отличное от 1, цикл завершается, и программа выводит финальное значение sum

 Переменная num **не избыточна**, она **фундаментально необходима**, если ты хочешь СКЛАДЫВАТЬ значения, а не перезаписывать.

Чтобы цикл работал правильно, нужно каждый раз:
1. **Считать новое число в `num` с помощью `scanf()`**.
2. **Проверить, успешно ли прошёл ввод, используя возвращаемое значение `scanf()`**, которое сохраняется в `status`.
`scanf()` возвращает:
- `1`, если число считано успешно;
- `0`, если ввод не является числом (например, `q`);
- `EOF` (`-1`), если произошёл конец ввода или ошибка.
Если `scanf()` не возвращала бы статус, нельзя было бы удобно определить, когда завершить цикл (например, если человек ввёл `0` или отрицательное число — это валидный ввод, и нельзя по самому `num` понять, пора ли выходить).
**Главная фишка**: цикл останавливается не потому что число какое-то особенное, а потому что `scanf()` не смог считать корректный `double`.
🧠 **Вывод**: комбинация `status = scanf(...)` и переменной `num` позволяет:
- читать данные;
- проверять корректность;
- удобно завершать цикл при любом нечисловом вводе.
Вот и всё. Без `num` — код сдохнет. Без проверки `status` — получишь вечный цикл идиотии.

В любом случае, поскольку **while** является **циклом с предусловием**, **программа должна получить входные данные и проверить значение переменной status до того, как будет произведен вход в тело цикла**. Именно по этой причине в программе имеется вызов функции scanf () перед while. Чтобы цикл мог продолжаться, внутри него должен присутствовать оператор чтения, который позволит определить значение переменной status для следующего входного значения. В связи с этим оператор scanf() присутствует также в конце цикла while; он подготавливает цикл к следующей итерации.

Общая форма цикла while имеет следующий вид: 
```
while (выражение) 
	  оператор
```
Часть операто р может быть простым оператором, завершающимся точкой с запятой, либо составным оператором, заключенным в фигурные скобки.

Если выражение **истинно** (имеет ненулевое значение), то часть *оператор* выполняется один раз и затем выражение проверяется снова. Такой повторяющийся процесс проверки и выполнения повторяется до тех нор, пока выражение не станет ложным (нулевое значение). Каждый процесс проверки и выполнения называется *итерацией*
![[Pasted image 20250415104332.png]]
При построении цикла while должен быть предусмотрен код, который изменяет значение проверочного выражения, чтобы оно в конечном итоге стало ложным. В противном случае цикл никогда не закончится. (можно применить операторы break и if)
```
index = 1;
while (index < 5)
	printf("ZZZZVVVV\n");
```
Фрагмент программы выводит это ободряющее сообщение бесконечно. Потому что, цикл ничего не меняет и "index" всегда остаётся = 1. 
```
index = 1;
while (++index < 5)
	printf("ZZZZVVVV\n");
```
Эта версия кода обеспечит завершение цикла после того, как значение переменной index станет больше 5
### Когда цикл завершается?
Важно понимать, что решение прекратить или продолжить выполнение цикла принимается только после того, как вычислено условие проверки
```
#include <stdio.h>
int main(void)
{
int n = 5;
while (n++ < 7){
  
    printf("n = %d\n", n) ;
    n++; // строка 10
    printf("Теперь n = %d\n", n); // строка 11
}
printf("Цикл завершен.\n");
return 0;
}
```
n =5, пока она не достигнет значения > 7, цикл не завершится.

Для примера предположим, что вы хотите пропустить входные данные до первого символа, который не является пробельным или цифровым. Можно воспользоваться таким циклом:
```
while (scanf("%d", &num) == 1)
	;
```
Для ясности точка с запятой (пустой оператор) должна размещаться в следующей строке, а не вместе с оператором while. Это упрощает распознавание пустого оператора, а также напоминает о том, что он включен преднамеренно. Но еще лучше применять оператор continue.

### continue
`continue` — **перебрасывает выполнение сразу в следующую итерацию цикла**, нахуй игнорируя всё, что ниже в теле цикла.
 
```
while (scanf("%lf", &num) == 1)
{
    if (num < 0)
        continue; // идем сразу к следующему вводу

    sum += num;
}
```
Всё логично: если хуйня — идём дальше, если норм — добавляем. Всё читается как конфетка, компилятор тебя любит, читатель уважает, Бог прощает.
#### Зачем и когда юзать `continue`?
- Когда хочешь **пропустить остаток цикла** при каком-то условии.
- Когда **не хочешь вкладывать всё в `if/else`**, чтобы сохранить **чистый поток кода**.

Поскольку циклы while часто полагаются на проверочные выражения, которые делают сравнения(Такие выражения называются вырежниями отношений, а операции, которые в них появляются — операции отношений).

| Операция | Чо               |
| -------- | ---------------- |
| <        | Меньше           |
| <=       | Меньше или равно |
| ==       | Равно            |
| >=       | Больше или равно |
| >        | Больше           |
| !=       | Не рвно          |
Операции отношений применяются для построения выражений отношения, используемых в операторах while.

Функция fabs(), объявленная в заголовочном файле math.h, может быть удобной при проверках, в которых участвуют числа с плавающей запятой:
```
#include <stdio.h>
#include <math.h>
int main ()
{
    const double ANSWER = 3.14159;
    double response;
    printf("Каково значение числа pi?: ");
    scanf("%lf", &response);
    while (fabs(response - ANSWER) > 0.0001)
{
    printf("Bвeдитe значение еще раз: ");
    scanf("%lf", &response);
}
    printf("Достаточно близко!\n");
    return 0;
}
```
> Каково значение числа pi?: 3.14
Bвeдитe значение еще раз: 3.1415
Достаточно близко!

## _bool_
В программировании переменные, представляющие истинные и ложные значения, известны как булевские. Переменная типа Bool может иметь только значения 1 (“истина”) и 0 (“ложь”)

```
#include <stdio.h>

#include <math.h>
int main ()
{
    long num;
    long sum = 0;
    _Bool input_is_good;
    printf("Введите целое число: ");
    input_is_good = (scanf("%ld", &num) == 1);
    while (input_is_good)
    {
        sum+=num;
        printf("Введите след. число: ");
        input_is_good = (scanf("%ld", &num) == 1);
    }
    printf("Сумма: %ld", sum);
    return 0;
}
```
результат сравнения переменной:
```
input_is_good = (scanf("%ld", &num) == 1);
```
Такое присваивание имеет смысл, поскольку операция == возвращает значение 1 или О

Можно подключить <stdbool.h>, где вместо 0 и 1 используется True и False.
## Цикл for
```
int main ()
{
    const int NUMBER = 22;
    int count;
    for(count = 1; count <= 100; count++)
        printf("Пошёл нахуй\n ");
    return 0;
}
```
Первое выражение — это инициализация. Она осуществляется только один раз при первом запуске цикла for. Второе выражение представляет собой условие проверки; оно вычисляется перед каждым потенциальным проходом цикла. Третье выражение, которое выполняет изменение или обновление, вычисляется в конце каждой итерации.

```
#include <stdio.h>
  
int main()
{
    int number;
    printf("Введите число: ");
    scanf("%d", &number);
    for (int i = 1; i <= number; i++){
        if(i % 2 == 0) {
            printf("число %d четное\n", i);
        } else{
            printf("число %d нечетное\n", i);
        }
    }
    return 0;
}
```
- `number` — это конечная граница (`i <= number`)
- `i` — это текущее число, которое надо проверить на чётность и вывести.
![[Pasted image 20250415122110.png]]

Таблица кубов
```
#include <stdio.h>
  
int main()
{
    int number;
    printf("Таблица кубов:\n");
    printf("    n    n^3\n");
    for(number = 1; number <= 9; number++) {
        printf("%5d %5d\n", number, number*number*number);
    }
    return 0;
}
```

```
#include <stdio.h>
  
int main()
{
    int secs;
    for(secs = 5; secs > 0; secs--){
        printf("%d секунд(ы)\n", secs);
    }
    printf("Машина заведена");
    return 0;
}
```

```
#include <stdio.h>

int main()
{
    char ch;
    for(ch = 'a'; ch <= 'z'; ch++){
        printf("Значение ASCII для %c = %d.\n", ch, ch);
    }
    return 0;
}
```
С 219 стр
В операторе for используются три управляющих выражения, разделяемые точками с запятой. Выражение инициализация вычисляется однократно до выполнения любых операторов внутри цикла. Затем вычисляется выражение проверка , и если оно истинно (или не равно нулю), то тело цикла выполняется один раз. Далее вычисляется выражение обнов­ление , после чего снова вычисляется выражение проверка. Оператор for представляет собой цикл с предусловием — решение о проходе цикла еще раз принимается перед входом в него. Таким образом, вполне возможно, что цикл не выполнится ни разу. Часть оператор может быть простым или составным оператором.
```
for (инициализация; проверка; обновление){
	оператор;
}
```

```
for (n=0;n<10;n++){
	printf(" %d %d\n", n, 2 * n + 1);
}
```

### Дополнительные операции присваивания: +=, -=, (D*)=, /=, %=
```
scores += 20 — то же, что и scores = scores + 20
dimes - = 2 — то же, что и dimes = dimes - 2
bunnies *= 2 — то же, что и bunnies = bunnies * 2 
time /= 2.73 — то же, что и time = time / 2.73 
reduce %= 3 — то же, что и reduce = reduce %
х *= 3*у+12 — то же, что и х=х*(3*у+12)
```

## Греческий философ Зенон и цикл for
**Зенон говорил:** стрела никогда не долетит до цели, потому что сначала она пролетает половину пути, потом половину оставшегося, потом ещё половину, и так бесконечно. Раз путь делится на бесконечно много частей — значит, и времени на это нужно бесконечно.
Применим количественный подход и предположим, что стреле требуется одна секунда, чтобы пролететь первую половину пути. Затем ей понадобится 1/2 секунды, чтобы пролететь половину оставшегося пути, еще 1/4 секунды, чтобы преодолеть половину пути, который остался после этого, и т.д.
**Но на самом деле:** даже бесконечно много всё меньших промежутков могут в сумме дать конечное число. Например:
```
1 + 1/2 + 1/4 + 1/8 + 1/16 ... 
```
То есть, если первая часть пути занимает 1 секунду, следующая — 0.5 секунды, потом 0.25 и т.д., то суммарное время будет **2 секунды**, а не бесконечность.

программа вычисляет сумму нескольких первых элементов этой последовательности. Переменная power_of_two принимает значения 1.0, 2.0, 4.0, 8.0 итд.
```
#include <stdio.h>
int main (void)
{
    int t_ct; // счетчик элементов
    double time, power_of_2;
    int limit;
    printf("Введите желаемое количество элементов последовательности: ");
    scanf("%d", &limit);
    for (time=0, power_of_2=1, t_ct=1; t_ct <= limit;
                                t_ct++, power_of_2 *= 2.0)
    {
    time += 1.0/power_of_2;
    printf("время = %f, когда количество элементов = %d.\n", time, t_ct);
    }
    return 0;
}
```
> Введите желаемое количество элементов последовательности: 13
время = 1.000000, когда количество элементов = 1.
время = 1.500000, когда количество элементов = 2.
время = 1.750000, когда количество элементов = 3.
время = 1.875000, когда количество элементов = 4.
время = 1.937500, когда количество элементов = 5.
время = 1.968750, когда количество элементов = 6.
время = 1.984375, когда количество элементов = 7.
время = 1.992188, когда количество элементов = 8.
время = 1.996094, когда количество элементов = 9.
время = 1.998047, когда количество элементов = 10.
время = 1.999023, когда количество элементов = 11.
время = 1.999512, когда количество элементов = 12.
время = 1.999756, когда количество элементов = 13.

Легко заметить, что хотя мы и добавляем все новые элементы, общая сумма, по-видимому, не превысит некоторой величины. И в самом деле, математики доказали, что сумма этой последовательности стремится к 2.0 по мере того, как количество просуммированных элементов стремится к бесконечности

Предположим, что S представляет собой такую сумму:
```
S = 1 + 1/2 + 1/4 + 1/8 + ...
```
Здесь многоточие означает “и т.д.”. Разделив S на 2, получаем:
```
S/2 = 1/2 + 1/4 + 1/8 + 1/16 + ...
```
Вычитание второго выражения из первого дает:
```
S - S/2 = 1 + 1/2 - 1/2 + 1/4 - 1/4 + ...
```
За исключением начального значения 1 все остальные значения образуют пары, в которых одно значение положительное, а второе — отрицательное, так что эти элементы уничтожают друг друга, в результате оставляя:
```
S/2 = 1
```
И, наконец, умножение обеих сторон на 2 дает:
```
S = 2 
```
Прежде чем начинать сложные вычисления, проверьте, не нашли ли математики более простого способа делать это. Что можно сказать о самой программе? Она показывает, что в выражении можно использовать более одной операции запятой. Вы инициализировали переменные time, power_of_2 и count. После того, как вы определили условия для цикла, программа оказалась совсем короткой.

## Цикл с постусловием: do while
Циклы while и for являются циклами с предусловием. Условия проверки вычисляются перед каждой итерацией цикла, поэтому вполне возможно, что операторы, помещенные в цикл, никогда не выполнятся. 
```
#include <stdio.h>
  
int main()
{
    const int secret_code = 1488;
    int entered_code;
  
    do
    {
        printf("Чтобы войти в рехаб, введите KEY: ");
        scanf("%d", &entered_code);
  
    } while (entered_code != secret_code);
    printf("Давай не заёбывай!");
    return 0;
}
```
> Чтобы войти в рехаб, введите KEY: 13
Чтобы войти в рехаб, введите KEY: 14
Чтобы войти в рехаб, введите KEY: 15
Чтобы войти в рехаб, введите KEY: 16
Чтобы войти в рехаб, введите KEY: 188
Чтобы войти в рехаб, введите KEY: 148
Чтобы войти в рехаб, введите KEY: 1488
Давай не заёбывай!

Либо можно переписать под While
```
#include <stdio.h>
  
int main()
{
    const int secret_code = 1488;
    int entered_code;
  
    while (entered_code != secret_code) {
        printf("Чобi войти в рехаб, введите пiроль: ");
        scanf("%d", &entered_code);
    }
    printf("Давай не заёбывай!");
    return 0;
}
```

Общая форма do while:
```
do 
	оператор
while ( выражение );
```
**Оператор может быть простым или составным. Обратите внимание на то, что сам цикл do while считается оператором и таким образом требует наличия после него точки с запятой**.
![[Pasted image 20250416212411.png]]
Например, программа запроса пароля могла бы содержать цикл, как демонстрируется в следующем псевдокоде:
```
do 
{
	Запрос пароля
	Прочитать введенный пароль
} while(введенные данны не совпадают с паролем);
```
**Избегайте применения структуры do while, которая имеет вид, подобный показанному ниже псевдокоду:**
```
do
{
	запросить пароль, желает ли он продолжить
	какие-то действия
} while(ответом является 'да');
```
**В этом случае, даже если пользователь ответит “нет” на запрос о продолжении, действия вес равно выполняются, т.к. проверка введенного ответа происходит слишком поздно.**

Оператор do while создает цикл, который повторяется до тех пор, пока проверочное выражение не станет ложным или нулевым. Оператор do while является циклом с постусловием, т.е. решение о следующем проходе цикла принимается после выполнения текущей итерации. Таким образом, цикл должен быть выполнен, по меньшей мере, один раз. Часть оператор может быть простым или составным оператором.

## Выбор подходящего цикла
Предположим, что требуется цикл с предусловием. Это должен быть цикл for или же цикл while? Частично это дело вкуса, поскольку то, что возможно сделать с помощью одного цикла, можно достичь и посредством другого. Чтобы сделать цикл for похожим на while, можно не указывать первое и третье выражения. Так, цикл
```
for (; Условие-проверки ;)
```
=
```
while(условие-проверки)
```
Чтобы придать циклу while вид, подобный for, предварите его инициализацией и предусмотрите внутри тела операторы для обновления значений
```
инициализация;
while(условие-проверки)
{
	тело-цикла;
	обновление;
}
```
=
```
for (инициализация; условие-проверки; обновление)
	тело цикла;
```
С позиций преобладающего стиля цикл for больше подходит в ситуациях, когда цикл предусматривает инициализацию и обновление переменной, а цикл while предпочтительнее, когда этого делать не нужно. Цикл while целесообразно применять для следующего условия:
```
while (scanf("%ld", &num) == 1)
```
Цикл for является более естественным выбором, когда реализуется подсчет для какого-нибудь индекса:
```
for (count = 1; count <= 100; count++)
```

## Вложенные циклы
Вложенный цикл — это цикл внутри другого цикла. Вложенные циклы часто используются для отображения данных в виде строк и столбцов. Один цикл может обрабатывать, скажем, все столбцы в строке, а второй цикл - все строки.
```
#include <stdio.h>
  
#define ROWS 6
#define CHARS 10
  
int main (void)
{
    int row;
    char ch;
    for(row = 0; row < ROWS; row++)
    {
        for(ch = 'A'; ch < ('A' + CHARS); ch++)
            printf("%c", ch);
        printf("\n");
    }
    return 0;
}
```
> ABCDEFGHIJ
ABCDEFGHIJ
ABCDEFGHIJ
ABCDEFGHIJ
ABCDEFGHIJ
ABCDEFGHIJ

Внешний цикл стартует при значении 0 переменной row и завершается, когда ее значение достигает 6. Таким образом, происходит шесть итераций внешнего цикла, и переменная row последовательно получает значения от 0 до 5. Первый оператор в каждой итерации является внутренним циклом for. Он выполняет 10 итераций, выводя символы от А до J в одной строке. Второй оператор внешнего цикла, printf( "\n") ; , начинает новую строку, так что при следующем выполнении внутреннего цикла вывод будет производиться в новой строке.

## Введение в массивы
Массивы являются важным инструментом во многих программах. Они позволяют хранить несколько элементов связанной информации в удобной форме. Массив — это совокупность значений одного и того же типа, которые хранятся в памяти последовательно. Массив целиком носит свое имя, а доступ к его отдельным элементами осуществляется с применением целочисленного индекса
```
#include <stdio.h>

  
int main (void)
{
    char array[] = {1,2,3,4,5,6,7};
    for (int i = 0; i < sizeof(array); i++){
        printf("%d", array[i]);
    }
    return 0;
}
```
char array[] = {1,2,3,4,5,6,7}; - Создание массива, где компилятор сам считает какое ограничение надо сделать по символам. В {} указаны числа;
Вывод через for, где ограничение(второй операнд) - вычисляется через sizeof(**возвращает размер массива в байтах: 1 символ - 1 байт, в примере получаем 7 байт - 7 символов** ).

Нумерация элементов массива начинается с 0, а не с 1. 
Каждому элементу массива может быть присвоено значение float:
```
debts[4] = 3,14;
```
В сущности, элемент массива можно использовать тем же самым образом, как это делалось бы с переменной такого же типа. Например, можно прочитать значение и поместить его в конкретный элемент:
```
scanf("%f", &debts[4]); //чтение значения в 5-й элемент массива
```

```
#include <stdio.h>
  
int main(void)
{
    int size, sum = 0;
    printf("Введите кол-во элементов в кошельке: ");
    if(scanf("%d", &size) != 1 || size <= 0) {
        printf("Че пиздишь??\n");
        return 1;
    }
  
    int wallet[size];
    printf("Окей, размер кошелька = %d\n", size);
    printf("Теперь заполните этот кошелек:\n");
  
    for (int i = 0; i < size; i++) {
        printf("Элемент %d: ", i + 1);
        scanf("%d", &wallet[i]);
        sum += wallet[i];
    }
  
    printf("Так, так, так... Твой кошелек имееет столько денег:\n");
    for (int i = 0; i < size; i++) {
        printf("%d ", wallet[i]);
    }
  
    printf("\nЭто: %d долларов\n", sum);
  
    return 0

}
```
> Введите кол-во элементов в кошельке: 3
	Окей, в твоей кошелке: 3 элементов
	Теперь заполним ваш кошелек деньгами:
	Элемент 1: 4
	Элемент 2: 5
	Элемент 3: 6
	ОГО!
	4 5 6
	А это.... 15 долларов

Работать с массивами и циклами гораздо удобнее, чем применять 10 операторов scanf() и 10 операторов printf() для чтения и вывода 10 результатов. Цикл for предлагает простой и прямолинейный способ использования индексов массива. 
Следует отметить, что элемент массива int обрабатывается подобно переменной типа int. **Для чтения переменной fue типа int применялся бы вызов scanf("%d", &fue). В программе выше считывается элемент wallet[size] типа int, поэтому используется вызов scanf("%d", &wallet (size)).**

## Пример цикла. использующего возвращаемое значение функции
Мы сохраним функцию простой, ограничив ее положительными целочисленными степенями. Тогда для возведения числа п в степень р переменную n нужно просто умножить на саму себя p раз. Это совершенно естественная задача для цикла. Вы можете установить переменную pow в 1, после чего многократно умножать ее на n:
```
for(i=1; i <= p; i++)
	pow *=n;
```
Теперь, когда построен алгоритм, мы можем решить, какие типы данных исполь-зовать. Показатель степени р, будучи целочисленным, должен иметь тип int. Чтобы обеспечить достаточный диапазон значений для переменной n и ее степеней, выбе-рем для переменных n и pow тип double.
Давайте далее обдумаем, как оформить функцию. Нам необходимо предоставить функции два значения, а она должна возвратить одно значение. Чтобы передать фун-кции необходимую информацию, можно определить два аргумента, один типа double и один типа int, указывающие число и степень. Как обеспечить возвращение функ-цией значения в вызывающую программу? Для написания функции с возвращаемым значением выполните следующие действия.
1. При определении функции установите тип значения, которое она возвращает. 
2. С помощью ключевого слова return укажите возвращаемое значение.
```
double power (double n, int p) // returns type double
{
	double pow = 1;
	int i;
	for (i = 1; i <= p; i++)
	pow *= n;
	return pow;
	// return the value of the variable pow
}
```
Чтобы объявить возвращаемый тип функции, предварите этим типом имя функ-ции, как это делается при объявлении переменной. Ключевое слово return заставля-ет функцию возвратить в вызывающую функцию значение, указанное после return. Здесь функция возвращает значение переменной, но она может также возвращать зна-чения выражений. Например, следующий оператор вполне допустим:
``return 2* x + b;``

Функция вычислит значение выражения и возвратит его. В вызывающей функ-ции возвращаемое значение может быть присвоено другой переменной, использова-но как значение выражения, передано в качестве аргумента другой функции (как в printf("%f", power (6.28, 3))) или просто проигнорировано.

Теперь давайте применим функцию в программе. При тестировании функции было бы удобно располагать возможностью передачи этой функции нескольких зна-чений, чтобы увидеть, как она реагирует. Это предполагает настройку цикла ввода. Естественным вариантом является цикл while. Функцию scanf() можно использо-вать для ввода двух значений одновременно. Если функция scanf() успешно про-читает два значения, она возвратит 2, поэтому циклом можно управлять, сравнивая возвращаемое значение scanf() со значением 2. Еще один момент: чтобы воспользо ваться функцией power () в программе, ее понадобится объявить, как вы объявляете применяемые в программе переменные.

```
#include <stdio.h>
#include <math.h>
  
double power(double n, int p) {
    double pow = 1;
    for (int i = 1; i <= p; i++) {
        pow *= n;
    }
    return pow;
}
  
int main() {
    double x, exp, xpow;
  
    printf("Введите число: ");
    if (scanf("%lf", &x) != 1) {
        printf("Че, еблан? Надо было число!\n");
        return 1;
    }
  
    printf("Введите степень: ");
    if (scanf("%lf", &exp) != 1) {
        printf("Ты совсем охуел? Где степень, мразь?\n");
        return 1;
    }
  
    xpow = power(x, (int)exp);
    printf("%.2lf в степени %d = %.2lf\n", x, (int)exp, xpow);

  
    return 0

}
```
>> Введите число: 3
	Введите степень: 4
	3.00 в степени 4 = 81.00
	Q - quit
	ПОШЁЛ НАХУЙ

## Использование цикла for с массивами
За счет использования массива вы избегаете необходимости объявлять 10 переменных с разными именами, по одной для каждого результата.
Кроме того, для чтения входных данных можно применять цикл for. 
Программа предназначена для подсчета общей суммы результатов, их среднего значения и гандикапа, который представляет собой разность между средним и стандартным результатом, или паром
```
#include <stdio.h>

#define SIZE 10
#define PAR 72
  
int main()
{
    int index, score[SIZE];
    int sum = 0;
    double average = 0.0;
  
    printf("Введите %d результатов игры в гольф:\n", SIZE);
    for (index = 0; index < SIZE; index++)
        scanf("%d", &score[index]); // чтение 10 результатов игры в гольф
    printf("Введены следующие результаты:\n");
    for (index = 0; index < SIZE; index++)
        printf("%5d", score[index]); // проверка введенной информации
    printf("\n");
    for (index = 0; index < SIZE; index++)
        sum += score[index]; // сложение результатов
    average = (double) sum / SIZE; // проверенный временем метод
    printf("Сумма результатов = %d, среднее значение = %.2lf\n", sum, average);
    printf("Полученный гандикап равен %.0lf.\n", average - PAR);
    return 0;
}
```
> Введите 10 результатов игры в гольф:
10 20 30 40 50 60 70 80 90 100
Введены следующие результаты:
   10   20   30   40   50   60   70   80   90  100
Сумма результатов = 550, среднее значение = 55.00
Полученный гандикап равен -17.

Работать с массивами и циклами гораздо удобнее, чем применять 10 операторов scanf () и 10 операторов printf () для чтения и вывода 10 результатов. Цикл for предлагает простой и прямолинейный способ использования индексов массива. Следует отметить, что элемент массива int обрабатывается подобно переменной типа int. Для чтения переменной fue типа in t применялся бы вызов scanf ("%d", & fue). В листинге 6.19 считывается элемент score [index] типа int, поэтому используется вызов scanf("%d", &score[index]) .

Во-первых, применение директивы #define для создания символической константы (SIZE), указывающей размер массива, является хорошей идеей. Эта константа используется в определении массива и при установке пределов в циклах. Если позже понадобится расширить программу для обработки 20 результатов, достаточно просто переопределить константу SIZE, сделав ее равной 20. Вам не придется изменять каждую часть программы, в которой участвует размер массива. Во-вторых, конструкция

```
for(index = 0; index < SIZE; i++)
```
Удобна для обработки массива с размером SIZE. Очень важно указывать правильные пределы массива. Первый элемент имеет индекс 0, и цикл начинается с установки index в 0. Поскольку нумерация начинается с 0, индексом последнего элемента является SIZE - 1. То есть десятый элемент массива — это score[9]. **Условие проверки index < SIZE обеспечивает это, делая последним применяемым значением index величину SIZE - 1**

В-третьих, в программах рекомендуется выводить на экран значения, которые были только что прочитаны (для эхо-контроля). Это помогает удостовериться в том, что программа обрабатывает именно те данные, которые ожидаются. 
В-четвертых, обратите внимание на использование трех отдельных циклов for. Вас может интересовать, действительно ли это необходимо. Можно ли объединить некоторые из операций в один цикл? **Да**, вы могли бы поступить так. Программа стала бы компактнее. Однако это противоречило бы принципу модульности . Идея, лежащая в основе этого термина, заключается в том, что программа должна быть разбита на отдельные модули, и каждый модуль должен решать одну задачу. Это облегчает чтение профаммы. Но что вероятно **даже важнее — модульность намного упрощает обновление или модификацию программы, потому что ее части не перемешаны. Когда вы обретете достаточные знания о функциях, то сможете поместить каждый модуль в функцию, улучшая модульность программы.**
## Использование функций с возвращаемыми значениями
Объявление, вызов и определение функции, а также применение ключевого слова return - все это базовые элементы в определении и использовании функции с возвращаемым значением
1. **Объявление (prototype)**  
    – Говорит компилятору: «Вот есть функция с таким-то именем, такими-то параметрами и типом возвращаемого значения».  
    – Нужно, если определение функции идёт ниже по коду или в другом файле, чтобы компилятор сразу «знал», как с ней обращаться.
2. **Определение (definition)**  
    – Содержит сам код функции — её «тело».  
    – Без объявления определение всё равно даёт компилятору всю информацию, но только после того, как он до него «докопается» в исходниках.
3. **Ключевое слово `return`**  
    – Завершает выполнение функции и передаёт вызывающему коду значение указанного типа.  
    – Если функция объявлена как возвращающая, например, `double`, то без `return` вы не сможете получить это значение.
- **Почему `scanf` не нужно объявлять вручную?**  
    Потому что вы включаете заголовок `#include <stdio.h>`, а в нём уже есть декларация `int scanf(const char *, …);`. Компилятор «знает» о `scanf` заранее.
- **Почему нужно объявлять свою `power`, если её определение ниже?**  
    Пока вы внутри `main` вызываете `power`, компилятор ещё не встретил её определение, и без предварительного объявления он не знает, какого типа у неё результат и сколько аргументов ждать.
- **Можно ли обойтись без объявления?**  
    Да — если определить функцию _до_ её первого применения. Но по стилю обычно ставят `main` первым, а вспомогательные функции — ниже или в отдельных файлах, поэтому объявления (`.h`-файлы или прототипы сверху) обязательны.
В итоге:
- Объявление сообщает интерфейс функции.
- Определение даёт реализацию.
- `return` отдаёт результат этой реализации обратно туда, откуда функция была вызвана.

Ключевые понятия
Цикл представляет собой мощный инструмент программирования. При написании цикла вы должны обращать особое внимание на следующие три аспекта.
1. Четкое определение условия прекращения цикла.
2. Обеспечение инициализации значений, задействованных в условии проверки цикла, перед первым их использованием.
3. Обеспечение в цикле действий по обновлению условия проверки на каждой итерации.
Условия проверки обрабатываются путем их числовой оценки. Результат, равный 0, трактуется как ложное значение, а любое другое числовое значение — как истинное. Выражения с операциями отношений часто выступают в качестве условий проверки и являются чуть более специфичными. Результатом такого выражения будет 1, сели оно истинно, и 0, если ложно, что соответствует значениям, разрешенным для нового тина Bool

Массивы состоят из расположенных рядом ячеек памяти со значениями одного и того же типа. Вы должны помнить, что нумерация элементов массива начинается с 0, поэтому последний элемент массива имеет индекс на единицу меньше количества элементов. В С не выполняется проверка допустимости значений индексов, так что ответственность за это возлагается целиком на вас.
**Использование функций включает три отдельных шага.** 
1. Объявление функции посредством ее прототипа. 
2. Выполнение функции внутри программы путем ее вызова. 
3. Определение функции.
Прототип позволяет компилятору проверять, корректно ли применяется функция, а определение функции указывает, как она должна работать. Прототип и определение функции являются примерами современного стиля программирования, предусматривающего разделение элемента программы на интерфейс и реализацию. Интерфейс описывает, как используется средство, что и делает прототип, а реализация далее расписывает конкретные действия, чем занимается определение функции.

Резюме
239

# ГЛАВА 7. Управляющие операторы С: ветвление и переходы 
```
#include <stdio.h>
  
int main() {
    const int FREEZING = 0;
    double temperature;
    int cold_days = 0, all_days = 0;
    printf("Введите список мин. дневных температур.\n");
    printf("Используйте шкалу Цельсия; Для завершения введите q.\n");
  
    while(scanf("%lf", &temperature) == 1) {
        all_days++;
        if(temperature < FREEZING)
            cold_days++;
    }
    if(all_days != 0)
        printf("Процент холодных дней: %.2f%%\n", 100.0 * cold_days / all_days);
    if(all_days == 0) {
        printf("Данные ввдены неверно.\n");
        return 0;
    }
}
```
Здесь мы создаем константу ХОЛОД равную 0
Потом создаем переменную в которую будем вводить температуру.\
Объявляем cold_days и all_days и приравниваем 0, т.к ключ.
В While проверяем, чтобы при вводе temperature удовлетворяло условию - только с плавающей запятой числа и если введём любое, но не число с плавающей запятой, то нас выкинет.
И добавляем всего дней + 1, потом проверяем, если температура меньше FREEZING(0), то добавляем 1 к cold_days
И если не равно 0, то высчитываем процент.

## getchar и putchar
**`getchar()`** — эта функция используется для того, чтобы считать один символ с клавиатуры. Когда ты вызываешь `getchar()`, программа приостанавливается, пока ты не нажмешь клавишу, и возвращает символ, который ты ввел. Это может быть как буква, так и цифра, пробел или любой другой символ.

```
ch = getchar();
```
Это будет тоже самое что и:
```
scanf("%c", &ch);
```

```
#include <stdio.h>

int main() {
    char c = getchar();  // Считывает один символ с клавиатуры
    printf("Ты ввел: %c\n", c);  // Выводит этот символ
    return 0;
}
```
>A
Ты ввел: A


**`putchar()`** — эта функция выводит один символ на экран. Ты передаешь ей символ, и она выводит его на экран. Это может быть полезно, если ты хочешь вывести какой-то символ, строку или результат вычислений в виде одиночных символов.
```
#include <stdio.h>

int main() {
    putchar('A');  // Выводит букву A на экран
    return 0;
}
```
Либо
```
#include <stdio.h>

int main() {
    char ch = 'P';
    putchar(ch);
    return 0;
}
```
- `getchar()` блокирует выполнение программы до тех пор, пока пользователь не введет символ.
- `putchar()` сразу выводит символ на экран, и выполнение программы продолжается.

Программа которая отображает введенную строку, но заменяет каждый отличный от пробела символ следую-щим за ним символом в последовательности кодов ASCII. Пробелы будут выводиться без изменений. Результат можно сформулировать так: "Если символ является пробе-лом, он выводится, в противном случае выводится символ, следующий за ним в после-довательности кодов ASCII".
```
#include <stdio.h>
  
#define SPACE ' '
  
int main() {
    char ch = getchar();
  
    while(ch != '\n')
    {
        if(ch == SPACE)
            putchar(ch);
        else
           putchar(ch+1);
        ch = getchar();
    }
    putchar(ch);
    return 0;
}
```

















































































