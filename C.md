**VSCODE:**
**// USE GOOGLE TRANSLATE: ALT+SHIFT+T**
**// USE GOOGLE SEARCH:  CTRL + ALT + G**
### Демонстрационная программа
```
#include <stdio.h>
int main(void)
{
    float weight; /* вес пользователя */
    float value; /* платиновый эквивалент */
    printf("Хотите узнать свой вес в платиновом эквиваленте?\n");
    printf("Давайте подсчитаем.\n");
    printf("Пожалуйста, введите свой вес, выраженный в фунтах: ");
    /* получить входные данные от пользователя */
    scanf("%f", &weight);
    /* считаем, что цена родия равна $1700 за тройскую унцию */
    /* 14.5833 коэффициент для перевода веса, выраженного в фунтах, в тройские унции */
    value = 1700.0 * weight * 14.5833;
    printf("Ваш вес в платиновом эквиваленте составляет $%.2f.\n", value);
    printf("Вы легко можете стать достойным этого! Если цена платины падает,\n");
    printf("ешьте больше для поддержания своей стоимости.\n" );
    return 0;
}
```
Ниже приведен пример вывода программы: 
```
Хотите узнать свой вес в платиновом эквиваленте?
Давайте подсчитаем. 
Пожалуйста, введите свой вес, выраженный в фунтах: 156 
Ваш вес в платиновом эквиваленте составляет $3867491.25. 
Вы легко можете стать достойным этого! Если цена платины падает, ешьте больше для поддержания своей стоимости.
```
![[Pasted image 20250402160608.png]]

## Переменные и константы
Программа должна работать с данными, т.е. числами и символами, несущими в себе необходимую информацию. Некоторые виды данных устанавливаются до начала выполнения программы и их значения сохраняются неизменными в течение всего времени ее работы. Такие данные называются *константами*. Другие виды данных могут изменяться в ходе выполнения программы. Они называются *переменными*
## Kлючевые слова для типов данных
Помимо отличий между переменными и константами, существует также разница между разных типами данных. Одни данные являются числами. Другие данные представляют собой буквы или, в общем случае, символы. Компьютеру необходим способ идентификации и использования этих разных видов данных. В языке С для этого предусмотрено несколько базовых типов данных.

| Ключевые слова в исходном стандарте K&R | Ключевые слова С90 | Ключевые слова С99 |
| --------------------------------------- | ------------------ | ------------------ |
| int                                     | signed             | _Bool              |
| long                                    | void               | _Complex           |
| short                                   |                    | _Imaginary         |
| unsigned                                |                    |                    |
| char                                    |                    |                    |
| float                                   |                    |                    |
| double                                  |                    |                    |

> [!NOTE] Биты, байты и слова
> Для описания элементов компьютерных данных или элементов компьютерной памяти могут применяться термины бит, байт и слово. 
> Минимальная единица памяти называется битом, который может хранить одно из двух значений: 0 или 1. (Иногда говорят, что бит “включен” или “выключен”.) Конечно, водном бите много информации сохранить не получится, но в компьютере их имеется огромное количество. Бит является базовым строительным блоком для памяти компьютера
> Байт — это наиболее часто используемая единица памяти компьютера. Практически на всех машинах байт состоит из 8 битов, и это является стандартным определением байта, по крайней мере, когда речь идет об измерении объема памяти. Поскольку бит может принимать значение 0 или 1, байт обеспечивает 256 (т.е. 2^8) возможных комбинаций нулей и единиц.
> Слово — это естественная единица памяти для компьютера конкретного типа. В 8-разрядных микрокомпьютерах, слово состояло из 8 битов. С тех пор персональные компьютеры перешли на 16-битные, 32-битные, а в настоящее время и 64-битные слова. Большие размеры слова позволяют быстрее передавать данные и делают доступным больший объем памяти.
### Целочисленные типы 
Основное - int.
В языке С применяются три ключевых слова, модифицирующих базовый целочисленный тин: short, long и unsigned:
- Тип short int, или short, может использовать меньший объем памяти, чем int, и тем самым экономить память в случае, когда требуются только небольшие числа. Подобно int, short является типом со знаком.
- Тип long int, или long, может занимать больший объем памяти, чем int, позволяя представлять крупные целочисленные значения. Подобно int, long является типом со знаком.
- Тип long long int, или long long, может занимать больше памяти, чем long. Для этого типа используются минимум 64 бита. Подобно int, long long является типом со знаком.
- Тип unsigned int, или unsigned, применяется для переменных, которые принимают только неотрицательные значения. Этот тип сдвигает диапазон хранимых чисел. Например, 16-битный тип unsigned int имеет диапазон значений от 0 до 65535 вместо диапазона от -32768 до 32767. Бит, который использовался для представления знака, теперь становится еще одной двоичной цифрой, делая возможным представление большего числа.
- Ключевое слово signed может применяться с любыми типами со знаком, чтобы явно указать свое намерение. Например, short, short int, signed short и signed short int являются именами одного и того же типа
### Объявление переменных других целочисленных типов
```
long int estine; 
long johns; 
short int erns;
short ribs;
unsigned int s_count;
unsigned players; 
unsigned long headcount; 
unsigned short yesvotes; 
long long ago;
```
### Константы long и long long
Обычно, когда в коде программы используется число вроде 2345, оно хранится в памяти как относящееся к типу int. А что произойдет, если указать число, такое как 1 000 000, в системе, где тип int не способен хранить настолько большое значение? В этом случае компилятор трактует его как число типа long int, предполагая, что этого типа окажется достаточно. Если число превосходит максимально возможное значение типа long, оно будет рассматриваться как значение типа unsigned long. Если и этого не достаточно, оно интерпретируется как значение типа long long или unsigned long long, если данные типы доступны.
### Вывод значений типов short, long, long long и unsigned
Для вывода чисел типа unsigned int применяйте спецификатор %u. 
Чтобы вывести значение типа long, используйте спецификатор формата %ld
%lx для вывода целого числа типа long в шестнадцатеричном формате; и спецификатор %lo — для его вывода в восьмеричном формате.
long long, для версий со знаком и без знака применяются спецификаторы %lld и %llu.

В языке С доступны дополнительные форматы для printf(). Первым делом, можно применять префикс h для значений типа short. Следовательно, спецификатор %hd отображает целое число типа short в десятичной форме, а спецификатор %ho отображает это же число в восьмеричной форме. Префиксы h и l можно использовать вместе с префиксом u для типов без знака.

```
/* print2.c -- дополнительные свойства функции printf () */
#include <stdio.h>
int main (void)
{
    unsigned int un = 3000000000; /* система с 32-битным типом int */
    short end = 200; /* и 16-битным типом short */
    long big = 65537 ;
    long long verybig = 12345678908642;
    printf("un = %u, but no %d\n", un, un) ;
    printf("end = %hd and %d\n", end, end) ;
    printf("big = %ld, but no %hd\n", big, big) ;
    printf("verybig = %lld, but no %ld\n", verybig, verybig) ;
    return 0;
}
```
">>"
```
un = 3000000000, but no -1294967296
end = 200 and 200
big = 65537, but no 1
verybig = 12345678908642, but no 1942899938
```
Этот пример демонстрирует, что использование неправильных спецификаторов может привести к неожиданным результатам. 
<mark style="background: #ABF7F7A6;">Далее отметим, что переменная end типа short отображается одинаково независимо от того, указываете вы функции printf() принадлежность end к тину short (%hd) или к типу int (спецификатор %d). Это объясняется тем, что при передаче аргумента типы short автоматически расширяется до типа int. </mark>
<mark style="background: #FF5582A6;">Здесь могут возникнуть два вопроса: почему предпринимается указанное преобразование, и для чего используется модификатор h? Ответ на первый вопрос прост: для типа int выбирался такой размер, чтобы обеспечить наиболее эффективную его обработку компьютером. Следовательно, на компьютере, в котором типы short и int имеют разные размеры, передача значения как int может осуществляться быстрее. Ответ на второй вопрос выглядит так: модификатор h можно применять, чтобы продемонстрировать, какой вид примет целое значение, будучи усеченным до типа short. 
</mark>
## СПЕЦИФИКАТОРЫ
[[Specifies C]]
## Использование символов: тип char
Тип данных char применяется для хранения символов, таких как буквы и знаки препинания, однако формально он также является целочисленным. К примеру, целое значение 65 в нем представляет прописную букву А. Таким образом, чтобы сохранить букву А, фактически нужно записать целое число 65
> [!NOTE] Стандартный код ASCII
> Cостоит из последовательности чисел от 0 до 127
### Объявление, инициализация переменных типа char
```
char response;
char grade = 'A';
```
Одиночный символ, заключенный в одиночные кавычки, представляет собой символьную константу.
```
char grade = 65;
```
В данном примере 65 имеет тип int. Но лучше применять не 65, а 'А'
### Управляющие последовательности

| Последовательность | Описание                                                         |
| ------------------ | ---------------------------------------------------------------- |
| \a                 | Предупреждение = звуковой сигнал                                 |
| \b                 | Возврат на одну позицию влево                                    |
| \f                 | Перевод страницы                                                 |
| \n                 | Новая строка                                                     |
| \r                 | Возврат каретки                                                  |
| \t                 | Горизонтальная табуляция                                         |
| \v                 | Вертикальная табуляция                                           |
| \\                 | Обратная косая черта ( \)                                        |
| \t'(без t, но с ') | Одиночная кавычка ( ' )                                          |
| \t"(тоже самое)    | Двойная кавычка (")                                              |
| \t?(тоже самое)    | Знак вопроса (?)                                                 |
| \t0oo(тоже самое)  | Восьмеричное значение (о представляет восьмеричную цифру)        |
| \xhh               | Шестнатеричное значение (h представляет шестнадцатеричную цифру) |
Управляющие последовательности, присваиваемые символьным переменным, должны быть заключены в одиночные кавычки.
```
char nerf = '\n';
```
А затем вывести переменную nerf, что обеспечит перемещение на следующую строку на принтере или на экране монитора.
### Печатаемые символы
Для указания на то, что должен быть выведен символ, в функции printf() используется спецификатор %c. При выводе значения переменной типа char с обычным спецификатором %d будет получено целое число. Спецификатор формата %с сообщает функции p r in t f () о необходимости отобразить символ с кодовым значением, равным этому целому числу
![[Pasted image 20250406170153.png]]

```
    char ch = 'A';
    printf("Код символа %c\n",  ch);
```
`%c` — значит "символ, мать его", и `printf` не ебет — ты даёшь символ, он печатает его. Всё просто.

a.k.a Строка
```
char str[] = "Hello, bitch!";
printf("%s\n", str);  // Выводит: Hello, bitch!
```
`%s` — значит "строка", и `printf` прёт до первого `\0`. Если `\0` нет — жди SEGFAULT, придурок.

Типа ты решил, что `\0` — это для слабаков?
```
char fuckery[5] = {'H', 'e', 'l', 'l', 'o'};
for (int i = 0; i < 5; i++) {
    printf("%c", fuckery[i]);
}
printf("\n");

```
Потому что `%s` ждёт `\0`, а тут его хрен догонишь. Так что без цикла — ты просто клоун на шоу "Дебаггинг с огнетушителем".

Тип char является типом со знаком. Диапазон от -128 до 127. 
### Переносимые типы: stdint.h и inttypes.h
Это **заголовочные файлы**, которые дают тебе **переносимые типы данных**, чтобы твой код не сосал на каждом втором компиляторе или архитектуре.

Ты писал:
```
int a = 5;
```
И думал: "Ну, это ж 4 байта, да?"
Ага, щас. **На одном компе 4 байта, на другом — 2, на третьем — 8.** Потому что `int` — это как настроение у бывшей: хрен предскажешь.

`stdint.h`: Прямиком в царство ясности
Тебе нужны чёткие, блядь, гарантии? Вот они:

| Тип      | Значение                              |
| -------- | ------------------------------------- |
| int8_t   | Ровно 8 бит, знаковый (`-128..127`)\| |
| uint8_t  | 8 бит, беззнаковый (`0..255`)         |
| int16_t  | 16 бит                                |
| uint16_t | 16 бит беззнаковый                    |
| int32_t  | 32 бита                               |
| uint32_t | 32 бита беззнаковый                   |
| int64_t  | 64 бита                               |
| uint64_t | 64 бита беззнаковый                   |
Да, **всё строго**, всё как на зоне — никаких неожиданностей.
```
#include <stdint.h>

int32_t x = 1337;
uint8_t y = 255;
```
Это будет работать **одинаково** хоть на печке, хоть на суперкомпьютере.

А что за `inttypes.h`
Это типа дружок `stdint.h`, но даёт ещё и:
1. **Макросы для `printf`** — чтоб не обосраться, когда печатаешь переносимые типы.
2. **Функции для парсинга (`scanf`)** этих же типов.

```
#include <inttypes.h>

int32_t val = 1337;
printf("Val = %" PRId32 "\n", val);

```

```
#include <stdio.h>
#include <stdint.h>
#include <inttypes.h>
  
int main()
{
    uint8_t num = 255;
    printf("num = %" PRId8 "\n", num);
    return 0;
}
```
Что за `%` `"PRId32"`?  
Это макрос, который будет **правильно работать на любой платформе**.
Если ты просто напишешь `%d`, а `int32_t` окажется `long` — всё пизда, undefined behavior уже дрочит тебе в окно.

Почему это важно?
Потому что если ты не используешь `stdint.h` и `inttypes.h`, ты буквально подписываешь контракт с дьяволом на тему:
- код у тебя будет непереносимый кусок говна;
- баги будут приходить из будущего и ебать тебя во сне;
- твоя IDE будет тебе врать, а компилятор — издеваться.

TL;DR для дегенератов:
- **`stdint.h`** — даёт **переносимые типы** (`int8_t`, `uint64_t` и прочее).
- **`inttypes.h`** — даёт макросы **для вывода и ввода** этих типов (`PRId64`, `PRIu8`, и т.д.).
- **Используй их, если не хочешь, чтобы твой код сломался на другом ПК, как ебаная жопа на морозе.**

Как в книге:
Язык C в стандарте C99 добавил **переносимые имена для целочисленных типов**, чтобы код не ломался на разных платформах.
**🔹Точные по ширине типы** (из `<stdint.h>`):
- `int32_t` — ровно 32 бита, если система это поддерживает.
- Если нет подходящего типа — такой не будет определён.

🔹 **Типы с минимальной шириной**:
- `int_least8_t` — **как минимум** 8 бит, может быть больше.
- Используются, если точная ширина недоступна.
    
🔹 **Быстродействующие типы**:
- `int_fast8_t` — самый **быстрый** доступный тип, способный хранить хотя бы 8 бит.
    
🔹 **Максимальные типы**:
- `intmax_t`, `uintmax_t` — **ебать как большие. Самые ёмкие знаковые и беззнаковые типы, какие есть на системе.
🔹 Для вывода этих типов через `printf` и `scanf`, подключай `<inttypes.h>`, который даст тебе нужные **макросы форматов** типа `PRId32` вместо е**ного угадывания `%d`, `%ld` и прочей херни.

Пиши универсальный код — пользуйся этими типами, и не завязывайся на "а вдруг у нас `int` — это 16 бит, а `long` — 32". Нахуй гадания, бери гарантированный тип и работай.

```
#include <stdio.h>
#include <stdint.h>
#include <inttypes.h>

int main ()
{

    int32_t me32; // me32 -- это 32-битная переменная со знаком
    me32 = 45933945;
    printf("Сначала предположим, что int32_t является int: ");
    printf("me32 = %d\n", me32);
    printf("Далее не будем делать никаких предположений. \n");
    printf("Вместо этого воспользуемся \"макросом\" из файла inttypes.h: ");
    printf("me32 = %" PRId32 "\n", me32);
    return 0;
}
```
## Типы float , double и long double
Разнообразные целочисленные типы нормально подходят для большинства проектов по разработке программного обеспечения. Тем не менее, ориентированные на математику и финансы программы часто оперируют числами с плавающей запятой. В языке С такие числа имеют тип float, double или long double.
Числа с плавающей запятой позволяют представлять намного больший диапазон чисел, включая десятичные дроби.

| Число         | Научн.форма | Экспоненциальная форма записи |
| ------------- | ----------- | ----------------------------- |
| 1 000 000 000 | 1.0*10^9    | 1.0e9                         |
| 123 000       | 1.23*10^5   | 1.23e5                        |
| 322,56        | 3.2256*10^3 | 3.2256e2                      |
| 0,000056      | 5.6*10^-5   | 5.6e-5                        |
 `float` — тупо минималка, но рабочая:
- **6 значащих цифр** — типа может точно держать `33.3333`, дальше будет шиза.
- **Диапазон**: от **10⁻⁷ до 10⁷**, т.е. если ты не работаешь с чёрными дырами — пойдёт.
- **32 бита**:
    - 8 бит — ебаная экспонента (с её знаком).
    - 24 бита — мантисса (это та часть, где реально хранится значение).
    - Это всё... хреново, если надо точность.

 `double` — в два раза мощнее:
- **10 значащих цифр минимум**, а обычно тебе дают аж **13** — хватит даже для подсчёта твоих провалов по жизни.
- **64 бита**:
    - Может либо:
        - увеличить **мантиссу** (=> точность растёт, меньше ошибок округления),
        - либо расширить **экспоненту** (=> можно хранить числа типа массы Солнца и госдолга США).
- В общем, **double — это float на стероидах**.

`long double` — если ты реально повернут на точности:
- Гарантируется только одно: **он не хуже double**, а может быть и ебически лучше — зависит от компилятора, системы и твоего везения.
- В реальности — может занимать **80, 96, 128 бит** и быть просто ебанутым по точности.

| Тип         | Размер | Значащих цифр | Для кого                                               |
| ----------- | ------ | ------------- | ------------------------------------------------------ |
| float       | 32     | >=6           | Для студента, который не знает, как устроен float      |
| double      | 64     | >=10(до 13)   | Для нормальных людей                                   |
| long double | 80+    | >= 13+        | Для тех, кто верит в магию π и число e с 1000 знаками. |
%% IEEE 754 %%
 Поведение по умолчанию:=
- **`2.3` → `double`**  
    Без всяких суффиксов любое число с плавающей точкой — **тип `double`**. Жри это и не ной.
 Суффикс `f` или `F` → `float`:
- Пример: `2.3f`, `9.11E9F`  
    Говорит компилятору: **"Не выпендривайся, это `float`, а не `double`."**  
    Полезно, если ты хочешь экономить память, быть нищебродом и ловить больше багов от потери точности.
F, который заставляет компилятор трактовать константу с плавающей запятой
Начиная со стандарта С99, в языке С имеется новый формат для выражения констант с илавающей запятой. В нем применяется шестнадцатеричный префикс (Ох или ОХ) с шестнадцатеричными цифрами, р или Р вместо е или Е и экспонента, которая является степенью 2, а не 10. Такое число может выглядеть следующим образом:

```
0xa.lfp10
```
a - это 10 в шестнадцатеричной системе, .lf - 1/16 плюс 15/256; f - это 15 в шестнадцатеричной системе; а p10 — это 2^10, или 1024. В результате полное значение равно (10 + 1/16 + 15/256) * 1024, или 10364,0 в десятичной форме записи
## Вывод значений с плавающей запятой
> [!NOTE]
> АХАХА, ну вот мы и добрались до ебучей **`printf()`**, этой дикой шлюхи, которая делает вид, будто умеет красиво печатать числа, но всё время подкидывает тебе сюрпризы.
### **%f**
- Печатает в **обычном десятичном формате**.
- Работает с `float` и `double`.  
    → Потому что **`float` в любом случае ебашится в `double`**, когда ты суёшь его в `printf()`.
    Пример:
```
printf("%f", 3.14);  // → 3.140000
```
### **%e** или **%E**
- Вывод в **экспоненциальной форме** — как будто ты ученый в лаборатории, а не студент, который скопировал код с StackOverflow.
```
%e -> 3.140000e+00
%e -> 3.140000e+00
```
### **%a** или **%A** (если поддерживается)
- Шестнадцатеричный вывод типа:
```
printf("%a", 3.14);  // → 0x1.91eb86p+1
```
## Для `long double` нужен **%Lf**, **%Le**, **%La**:
- `%Lf` → десятичный
- `%Le` → экспоненциальный
- `%La` → шестнадцатеричный, если не откажется скомпилироваться
```
printf("%lf", 3.14);  // → ну найдёшь
```

> [!NOTE] Но какого хера `float` и `double` используют одни и те же спецификаторы?
> Потому что C — это **старый ублюдок**, в котором при передаче аргументов в функцию без строго заданного прототипа (а `printf` — именно такая), **`float` автоматически кастится в `double`**.
> Это называется **default argument promotion**, и тебе придётся с этим мириться. Либо страдать, как твой дебаггер.

TL;DR:

| Тип          | Формат | Пример     |
| ------------ | ------ | ---------- |
| float/double | %f     | Обыч.число |
| float/double | %e/%E  | Экспонента |
| float/double | %a/%A  | HEX        |
| long double  | %Lf    | Десятичное |
| long double  | %Le    | Экспонента |
| long double  | %La    | HEX        |
```
#include <stdio.h>

int main(void)
{
    float aboat = 32000.0;
    double abet = 2.14e9;
    long double dip = 5.32e-5;
    printf("%f может быть записано как %e\n", aboat, aboat);
    printf ("И его %a в шестнадцатеричной, представляющей степени 2, форме записи\n", aboat);
    printf("%f может быть записано как %e\n", abet, abet);
    printf("%Lf может быть записано как %Le\n", dip, dip);
    return 0;
}
```

> 32000.000000 может быть записано как 3.200000e+004
И его 0x1.f40000p+14 в шестнадцатеричной, представляющей степени 2, форме записи
2140000000.000000 может быть записано как 2.140000e+009
-1950228512509697500000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000.000000 может быть записано как 2.725002e+002

Микроскопическое деление:
Представим, ты хочешь делить и так уже минимальное число `float` на 2.
Вот тут начинается настоящее **дно в подвале точности**:
- Число уже на минимуме экспоненты (степени).
- Делишь на 2? Экспоненту уже **нельзя уменьшить**, поэтому происходит **сдвиг мантиссы** вправо.
- Это даёт тебе **субнормальное число**: оно **меньше, чем может быть представлено "нормальным" float'ом**, и **теряет точность**.
```
float smallest = 1.4e-45; // или FLT_MIN, или ещё меньше
float half = smallest / 2; // → субнормальное значение
```
>half = 0.000000e+000

🧟‍♂️ Что такое субнормальные числа?
- Значения, которые **слишком малы**, чтобы вписаться в нормальный `float`, но всё ещё **ненулевые**.
- Поддерживаются не на всех архитектурах.
- **Дико тормозят**, если у тебя железо их не любит.
- Считай, это **инвалидность чисел** — вроде живое, но нормальным уже не назвать.

💩 А что за NaN?
```
float x = sqrtf(-1.0f); // Или asin(10.0f)
printf("%f\n", x); // → nan

```
>-1.#IND00

Возникает, когда ты:
- Делишь ноль на ноль
- Пытаешься взять логарифм от отрицательного
- Пихаешь в `asin()` число больше 1
- Или вызываешь `tan(PI/2)` и удивляешься
## Комплексные и мнимые типы
нахуй не нужны
## Сводка: базовые типы данных

### Целые числа с о знаком
Они могут иметь как положительные, так и отрицательные значения
int — базовый целочисленный тип в заданной системе. Язык С гарантирует для int не менее 16 битов. 
• short или short int — максимальное целое число типа short не превосходит наибольшего целочисленного значения типа int. Язык С гарантирует для short не менее 16 битов. 
• long или long int — может хранить целое число, которое, как минимум, не меньше наибольшего числа типа int или больше его. Язык С гарантирует для long не менее 32 битов. 
• long long или long long int — этоттип может быть целым числом, которое, как минимум, не меньше наибольшего числа типа long, а, возможно, и больше его. Для long long гарантируются не менее 64 битов.
Обычно тип long имеет большую длину, чем short, а длина типа int совпадает с длиной одного из этих типов. Н
### Целые без знака
Такие типы хранят только нулевое или положительные значения. Это расширяет диапазон до большего возможного положительного числа. Указывайте ключевое слово unsigned перед желаемым типом: unsigned int, unsigned long, unsigned short. Одиночное ключевое unsigned означает то же, что и unsigned int.
### Символы
Ими являются типографские символы, такие как а , & и +. По определению тип char для представления символа использует 1 байт памяти. Исторически сложилось так, что байт символа чаще всего имеет длину 8 битов, но он может быть длиной 16 битов или больше, если это необходимо для представления базового набора символов.
- char — ключевое слово для этого типа. В одних реализациях применяется тип char со знаком, в других он без знака. Язык С позволяет использовать ключевые слова signed и unsigned для указания нужной формы.
### Булевские значения
Булевский тип представляет значения true (истина) и false (ложь); в языке С для представления true применяется 1, а для представления false — 0.
Bool — ключевое слово для этого типа. Он является типом int без знака и должен быть настолько большим, чтобы обеспечить хранение значений из диапазона от 0 до 1
### Вещественные числа с плавающей запятой
• float — базовый тип данных с плавающей запятой в системе; он может представлять, по меньшей мере, шесть значащих цифр с заданной точностью. 
• double — (возможно) большая единица для хранения чисел с плавающей запятой. Этот тип может разрешать большее количество значащих цифр (минимум 10, но обычно больше) и, возможно, большие значения показателя степени, чем тип float. 
• long double — (возможно) еще большая единица для хранения чисел с плавающей запятой. Этот тип может разрешать большее количество значащих цифр и, возможно, большие значения показателя степени, чем тип double.

### Сводка: объявление простой переменной
1. Выберите необходимый тип данных. 
2. Выберите имя для переменной, включающее разрешенные символы. 
3. Применяйте следующий формат для оператора объявления: 
спецификатор-типа имя-переменной;
Компонент спецификатор-типа образуется из одного или большего количества ключевых слов для типов; вот примеры объявлений: 
int erest; 
unsigned short cash;
 4. Вы можете объявлять сразу несколько переменных одного и того же типа, разделяя имена переменных запятыми. Например: char ch, init, ans; 
 5. Вы можете инициализировать переменную в операторе объявления:  float mass = 6.0Е24;

## Размеры типов
Какие размеры типов используются в вашей системе? Чтобы выяснить это, попробуйте выполнить программу
```
int main(void)
{
    /* В стандарте с99 для размеров предусмотрен спецификатор %zd */
    printf("Тип int имеет размер %zd байт(ов).\n", sizeof(int));
    printf("Тип char имеет размер %zd байт(ов).\n", sizeof(char));
    printf("Тип long имеет размер %zd байт(ов). \n", sizeof(long));
    printf("Тип long long имеет размер %zd байт(ов). \n", sizeof(long long));
    printf("Tип double имеет размер %zd байт(ов) .\n", sizeof (double) ) ;
    printf("Тип long double имеет размер %zd байт(ов).\n",
    sizeof(long double)) ;  
    return 0;
}
```
В языке С имеется встроенная операция sizeof, которая возвращает размер типа в байтах. Для такого применения sizeof предоставляется спецификатор **%zd**
 Кстати, в нескольких последних строках обратите внимание на то, что оператор printf() можно разнести на две строки. Его можно разделять на большее количество частей при условии, что разрыв не происходит внутри раздела, заключенного в кавычки, или в середине слова.
 ```
 int main(void)
{
    printf("Введи ваш возраст: ");
    int32_t age;;
    scanf("%" SCNd32, &age);
    printf("Ваш возраст: %" PRId32, age);
    printf("\nРазмер вашего возраста в битах: %zd\n", sizeof(int32_t) * 8);
    return 0;
}
```
## Сброс буфера вывода
Функции типа `printf()` пишут не **на экран напрямую**, а сначала **в буфер** — типа такая временная заначка, где текст тусуется, пока системе не вздумается. 
Но иногда тебе **нужно сразу**, без задержек — типа ты делаешь:
```
printf("Введите имя: ");
```

💣 Решение: **`fflush(stdout);`**
```
printf("Введите имя: ");
fflush(stdout);  // вот теперь точно покажет, сцука
```
Это прямой **пинок под зад**: "Очисть буфер и вылей всё, что накопилось, на экран!"
fflush(stdout); после printf гарантирует, что текст приглашения будет виден пользователю до того, как программа начнет ждать ввода.
### 🧻 Когда это нужно?
- Когда ты просишь ввод (`scanf`, `fgets`) после `printf`.
- Когда stdout направлен не в терминал, а в файл/канал/жопу.
- Когда хочешь **гарантировать порядок вывода**.
- Когда ловишь баги и хочешь, чтобы сообщения **отображались в нужный момент**, а не “когда-нибудь потом”.

### ⚠️ Что НЕ стоит делать
Не вздумай писать `fflush(stdin);` — **это undefined behavior, ёпт!** Если ты делаешь так:
```
fflush(stdin); // Молишься, чтобы не взорвалось
```
...то стандарт C идёт к тебе в гости и **срет тебе в тапки**.  
Это не очищает ввод, это вызывает анальное страдание у компиляторов.

🧼 Если хочешь очистить **ввод** — делай правильно:
```
int c;
while ((c = getchar()) != '\n' && c != EOF);

```

```
int main()
{
   char name[50];
    printf("Введи своё жалкое имя: ");
   fflush(stdin);
    scanf("%49s", name);
    printf("Пидар, тебя зовут: %s", name);
    return 0;
}
```

<mark style="background: #FF5582A6;">ЛУЧШЕ ИСПОЛЬЗОВАТЬ "\n" - ЗДРАВЫЙ ПАЦАН</mark>
### 👊 TL;DR:
- `fflush(stdout);` — **сбрасывает буфер вывода**. Показывает текст сразу.
- Нужен, чтобы не сидеть, как идиот, ожидая вывода.
- Не еби мозг компилятору с `fflush(stdin)` — только для `stdout`, `stderr`, `files`.
# Символьные строки и форматированный ввод-вывод
```
#include <stdio.h>
#include <string.h>
// #include <stdint.h>
// #include <inttypes.h>
#define FOOT 2.2046
int main()
{
    double weight, weight2;
    int age, letters;
    char name[40];
 
	printf("Введите ваше имя: ");
    scanf("%39s", name);

    printf("Введите ваш вес в КГ: ");
    
    scanf("%lf", &weight);
    printf("Введите ваш возраст: ");
    
    scanf("%d", &age);
    printf("\n");
  
    weight2 = weight * FOOT;
   
	printf("Ваше имя: %s, состоящее из: %zu букв,", name, strlen(name));
    printf(" для него мы заняли: %zd байт.\n", sizeof(name));
    printf("Ваш вес в КГ: %.2lf, а в фунтах это будет: %.2lf \n", weight, weight2);
    printf("Ваш возраст: %d, для которого мы заняли: %zd", age, sizeof(age));
    printf(" байта\n");
    return 0;
}
```

>Ваше имя: Аллах, состоящее из: 10 букв
Ваш вес в КГ: 1488.000, а в фунтах это будет: 3280.445
Для него мы знаняли: 320 бит
Ваш возраст: 1488, для которого мы заняли: 32 битт
## Введение в символьные строки
Символъния строка - это последовательность из одного или большего количества символов. Двойные кавычки не являются частью строки. Они сообщают компилятору, что внутри них содержится строка
## Массив типа char и нулевой символ
В языке С не существует какого-то специального типа для строковых переменных. Вместо этого для строк применяются массивы типа char. Символы в строке хранятся в смежных ячейках памяти, по одному символу на ячейку, а массив состоит из смежных ячеек памяти, так что строка размещается в массиве вполне естественным образом
![[Pasted image 20250407230811.png]]
В последней позиции массива находится символ \0. Он представляет собой нулевой символ, который в языке С служит для пометки конца строки. Нулевой символ - это не цифра ноль, а непечатаемый символ, кодовое значение которого в кодировке ASCII равно 0. Строки в С всегда сохраняются с завершающим нулевым символом.
Присутствие нулевого символа означает, что массив должен иметь, по крайней мере, на одну ячейку больше, чем количество символов, которые требуется сохранить. Таким об разом, когда приведенная программа сообщает, что она располагает 40 байтами для стро ки, это означает, что она может хршпить вплоть до 39 символов плюс нулевой символ.
Что же такое массив? Массив можно представить как несколько ячеек памяти, расположенных подряд. Другими словами массив - но упорядоченная последовательность элементов данных одного типа:
```
char name[40];
```
Квадратные скобки после имени name идентифицируют его как массив.
![[Pasted image 20250407231026.png]]
## Использование строк(char)
```
#include <stdio.h>
#define PIDOR "Аллах пидар, кстати"
  
int main()
{
    char name[12];
    scanf("%11s", name);
    printf("%s. %s\n", name, PIDOR);
    return 0;
}
```
Спецификатор %s сообщает функции printf() о необходимости вывода строки. Он встречается дважды, т.к. программа выводит две строки: одна хранится в массиве name, а другая представлена PIDOR.
>Аллах. Аллах пидар, кстати

Если в массив Char забубенить имя  и фамилию
```
char name[40];
scanf("%49s", name);
И вывести: Пизда Ивановна
```
То, она останавливает чтение на первом встреченном пробельном символе (символе пробела, табуляции или новой строки).  считывание для массива name прекращается, когда появляется символ пробела между словами “Пизда” и “Ивановна”. 
В языке С доступны другие функции ввода данных, такие как fgets(), поддерживающая общие строки
## Функция strlen()
Функция strlen() возвращает длину строки в символах.
Поскольку для размещения одного символа требуется один байт, можно было бы предположить, что применительно к строке sizeof и stlen() дадут один и тот же результат, однако это не так.

```
#include <stdio.h>
#include <string.h>
s
#define POUNDS 2.2046
  
int main()
{
    char name[20];
    unsigned short age;
    double weight, weighttopounds;
    printf("Введите ваш возраст: ");
    scanf("%hd", &age);
    printf("Введите ваше имя: ");
    scanf("%39s", name);
    printf("Введите ваш вес в КГ: ");
    scanf("%lf", &weight);
    weighttopounds = weight * POUNDS;
    printf("Ваше имя: %s\n", name);
    printf("Ваш возраст: %d\n", age);
    printf("Ваш вес в КГ: %.2lf, а в фунтах: %.2lf\n", weight, weighttopounds);
  
    printf("Ваше имя содержит: %zd символов\n", strlen(name)/2);
    printf("И занимает: %zd бит \n", sizeof(name));
  
    return 0;

}
```
Массив name имеет 20 ячеек памяти, и именно об этом сообщает операция sizeof. Name необходимы только первые 10 ячеек, и об этом информирует функция strlen().Однако для размещения имени Васёк необходимы только первые 10 ячеек, и об этом информирует функция strlen()
**STRLEN считает байты, по этому здесь будет 10, заместо 5, т.к в UTF-8 Русские буквы содержат 2 знака, а не один.**  
![[Pasted image 20250409122837.png]]
## Константы и препроцессор с
Лучше использовать цифры, вместо букв. Для большего понимая. Пример:
```
square = storona * pi
```
и 
```
square = storona * 3,141592
```
Второй вариант более читаемый и понятный.
Либо
```
#define PI 3,141592
square = storona * PI
```

Директиву #define можно использовать также для объявления символьных и строковых констант. Достаточно указать одиночные кавычки для символьных и двойные кавычки для сфюковых констант.

```
#define ВЕЕР '\а'
#define ТЕЕ 'Т'
#define ESC '\033'
#define OOPS "Теперь вы сделали это!"
```
## Модификатор const
#define  - это дохуя тупой препроцессорный макрос.
const - это ёбаный модификатор, который говорит: "_Эта переменная, сука, **неизменяемая**. Кто попытается её поменять — получит по рукам компилятором._"
```
const int MONTHS = 12;
```
— Всё. Никакого ебучего переприсваивания. Попробуешь:
```
MONTHS = 13; // компилятор: пошёл нахуй
```
#define - хуита!!!
## limits.h и float.h
Заголовочные файлы limits.h и float.h содержат подробную информацию об ограничениях размеров, соответственно, целочисленных типов и типов сплавающей запятой. В каждом файле определена последовательность символических констант, которые применяются к реализации.

![[Pasted image 20250409135822.png]] ![[Pasted image 20250409135830.png]]
Анлагично , в файле float.h определены такие константы, как FLT_DIG и DBL_DIG, которые представляют количество значащих цифр, поддерживаемое типами float и double.
![[Pasted image 20250409135816.png]]

```
//defines.c — использует именованные константы из файла limit.h и тип float.
#include <stdio.h>
#include <limits.h> // пределы для целых чисел
#include <float.h> // пределы для чисел с плавающей запятой
int main()
{
    printf("Некоторые пределы чисел для данной системы:\n");
    printf("Наибольшее значение типа int: %d\n", INT_MAX) ;
    printf("Наименьшее значение типа long long: %lld\n", LLONG_MIN);
    printf("B данной системе один байт = %d битов.\n", CHAR_BIT);
    printf ("Наибольшее значение типа doUie: %e\n", DBL_MAX);
    printf("Наименьшее нормализованное значение типа float: %e\n", FLT_MIN);
    printf( "Toчнocть значений типа float = %d знаков^", FLT_DIG) ;
    printf( "Разница между 1.00 и минимальным значением float, которое больше 1.00 = %e\n", FLT_EPSILON);
    return 0;
}
```
## Спецификаторы преобразования вывода

| Спецификатор | Тип          | Пример | Вывод                       |
| ------------ | ------------ | ------ | --------------------------- |
| %d           | int          | 123    | Десятичное                  |
| %i           | int          | 123    | То же, что `%d`             |
| %u           | unsigned int | 123    | Без знака                   |
| %x           | unsigned int | 255    | hex (нижний регистр, `ff`)  |
| %X           | unsigned int | 255    | hex (верхний регистр, `FF`) |
| %o           | unsigned int | 8      | восьмеричное (`10`)         |
**Символы и строки**

| Спецификатор | Тип   | Пример  | Вывод |
| ------------ | ----- | ------- | ----- |
| %c           | char  | 'A'     | A     |
| %s           | char* | "hello" | hello |
**Числа с плавающей запятой**

| Спецификатор | Тип          | Пример | Вывод                                 |
| ------------ | ------------ | ------ | ------------------------------------- |
| %f           | float/double | 3.14   | Обычное десятичное (3.140000)         |
| %.2f         | float/double | 3.14   | С точностью (3.14)                    |
| %e           | float/double | 3.14   | Экспоненциальная форма (3.140000e+00) |
| %E           | float/double | 3.14   | То же, но с `E`                       |
| %g           | float/double | 3.14   | Автоматически `%f` или `%e`           |
| %a           | float/double | 3.14   | hex float                             |
**Модификаторы размера типа:**

| Спецификатор | Тип            | Комментарий          |
| ------------ | -------------- | -------------------- |
| %hhd         | signed char    | Маленькие числа      |
| %hd          | short          |                      |
| %hu          | unsigned short |                      |
| %ld          | long           |                      |
| %lld         | long long      |                      |
| %zd          | size_t         | Для указателей длину |
| %Lf          | long double    | Чистая боль          |
|              |                |                      |
**Указатель(адрес)**

| Спецификатор | Тип              | Комментарий |
| ------------ | ---------------- | ----------- |
| %p           | Указатель(адрес) |             |


❌ Чего **НЕ** делать:
- `%lf` в `printf()`? **НЕ НУЖНО** — `float` всегда промоутится до `double`.
- `%f` для `float`? **ДА**, нормально, жри.
- `%s` без `\0`? **Подпишись на свою смерть.**


Пример:
```
#include <stdio.h>
#define PI 3.141593
int main (void)
{
    int number = 7;
    float pies = 12.75;
    int cost = 7800;
    printf("%d участников соревнований съели %f пирожков с вишнями.\n", number, pies);
    printf("Значение pi равно %f.\n", PI);
    printf("До свидания! Ваше искусство слишком дорого обходится,\n");
    printf("%c%d\n", '$', 2 * cost);
    return 0;
}
```

**Так же выражение можно вывести в квадратных скобках:**
```
    printf("[%2d] участников соревнований съели %f пирожков с вишнями.\n", number, pies);
```
> [ 7] участников соревнований съели 12.750000 пирожков с вишнями.

### Вывод длинных строк
Иногда операторы printf () оказываются слишком длинными , чтобы уместиться в одной строке файла исходного кода. оператор можно разнести на несколько строк, при условии, что разрывы строк размещаются строго между элементами.
```
printf("Функция printf() вывела %d символов.\n", 
		rv);
```
В данном случае строка разбита между элементами запятой и rv. Чтобы показать читателю кода, что строка имеет продолжение, применяется оступ.

Однако нельзя разрывать строку внутри кавычек.
```
рrintf("Функция printf() вывела %d 
		символов.\n", rv) ;
```
В таком случае компилятор cообщит об использовании недопустимого символа в строковой константе.

**Когда требуется разбить строку, для этого существуют три возможности:**
```
#include <stdio.h>
int main(void)
{
    printf("Вот один из способов вывода ");
    printf("длинной строки.\n");
    printf("Вот второй способ вывода \
    длинной строки.\n");
    printf("A вот самый новый способ вывода "
    "длинной строки.\n"); /* ANSI С */
    return 0;
    }
```

### Использование функции scanf()
Функция scanf() позволяет помещать в строку формата обычные символы
```
scanf("%d,%d", &n, &m);
```
Функция scanf() интерпретирует эту сроку так, что вам придется набрать число, затем запятую и, наконец, второе число.
> 88, 121

Модификатор * в функциях printf ( ) и scanf()
**В `printf()`**: Модификатор `*` используется для динамического указания ширины поля, которое нужно использовать для вывода. То есть, вместо того чтобы задавать фиксированную ширину вывода напрямую, вы можете передать значение через аргументы функции
```
int width = 10;
printf("%*d\n", width, 42);  // Ширина поля будет 10
```
**В `scanf()`**: Модификатор `*` используется для пропуска считывания значения. Когда вы используете `*` перед типом данных, функция `scanf()` игнорирует ввод для этого параметра, то есть оно просто пропускается, но остальные значения считываются как обычно.
```
int a, b;
scanf("%d *%d", &a, &b);  // Пропускаем одно число
```
В этом примере, если в строке ввода будет два числа, то первое число будет считано в переменную `a`, а второе игнорируется из-за использования `*`, и только третье число будет записано в переменную `b`. Указывает программе н а необходимость пропуска двух целых чисел и копирования третьего целого числа в переменную n

```
#include <stdio.h>

int main() {
    int width = 10;
    int number = 42;
    
    // %*d позволяет задать ширину поля для целого числа
    printf("Number with dynamic width: %*d\n", width, number);
    
    return 0;
}
```
`%*d` указывает, что ширина поля для целого числа будет задана динамически.
Мы передаем значение переменной `width` (в данном случае это 10) перед числом, которое нужно вывести (`number`).
> Number with dynamic width:         42

```
#include <stdio.h>

int main()
{
    char name[50];
    int width, widthforname;
    printf("Введите ширину поля: ");
    scanf("%d", &width);
  
    printf("Введите ширину поля для имени: ");
    scanf("%d", &widthforname);
  
    printf("Введите ваше имя: ");
    scanf("%49s", name);
  
    printf("%*sПривет, \"%*s\"\n", width, "", widthforname, name);
  
}
```

`%.*f` указывает, что точность для вывода числа с плавающей точкой будет задана динамически.
```
#include <stdio.h>

int main() {
    int precision = 3;
    double value = 3.141592653589793;
    
    // %.*f позволяет задать точность для числа с плавающей точкой
    printf("Value with dynamic precision: %.*f\n", precision, value);
    
    return 0;
}

```
Переменная `precision` передается в функцию `printf()`, чтобы указать количество знаков после запятой.

#  Глава 5: Операции, выражения и операторы
## Введение в циклы
```
#include <stdio.h>
#define ADJUST 7.31 // константа 2
int main (void) 
{
    const double SCALE = 0.333; // константа 2
    double shoe, foot;
    printf("Размер обуви (^мужской) длина ступни\n");
    shoe = 3.0;
    while (shoe < 18.5)
{
    foot = SCALE * shoe + ADJUST;
    printf("%10.lf %20.2f даймов\n", shoe, foot);
    shoe = shoe + 1.0;
}
printf("Если обувь подходит, носите ее.\n");
return 0;
}
```
Выполняется проверка того, принимает ли условие в круглых скобках значение true.
Переменная shoe инициализирована значением З.0,  меньше чем 18.5. Поэтому условие равно **true** и переходит на следующий оператор, который преобразует размер в дюймы . Затем программа выводит результат. Следующий оператор увеличивает значение shoe на 1.0.
```
shoe = shoe + 1.0;
```
Как только значение shoe становится false, программа заканчивает выполнение 
# Фундаментальные операции
знак = не означает “равно".  Вместо этого им обозначается операция присваивания значения. 
```
bmw = 2000;
```
Оператор присваивает 2000  переменной bmw.

в С был добавлен термин **модифицируемое l-значение** для идентификации объекта , чье значение может изменяться.
Термин **r-значение** относится к величинам , которые могут быть присвоены модифи­цируемым l-значениям , но которые сами не являются  l-значениями:
- r-значении происходит от слова “right ” — “правая часть ”
- R-значениями могут быть константы, переменные или любое другое выражение, которое в результате даёт значение.

```
bmw = 2002;
```
bmw = l-знач., а 2002 = r-знач. 

```
int ex;
int why;
int zee; 
const int TWO = 2;
why = 42;
zee = why;
ex =TWO * (why + zee);
```
ex, why, zee - модифицируемые l-знач. Они могут использоваться слева или справа от символа операции присваивания. 
TWO - не модифицир. l-знач., оно может указываться только в правой части. 
42 - r-знач. 

Вырисовывается подходящий термин для того, что мы называем "элементом" (примером может служить фраза "элемент слева от знака =") - операнд. Операнд - это то, чем оперируют операции. 

Многие языки программирования не разрешают тройное присваивание значений, сделанного в этой программе, но в С это считается обычным делом:
```
cheeta = drita = pizza = 1488;
```


## Операция sizeof И тип size_t
Вспомним, что **sizeof** - *она возвращает размер своего операнда в байтах.* 
```
sizeof(int);        // обычно 4
sizeof(char);       // всегда 1, потому что 1 байт
sizeof(double);     // обычно 8
sizeof(arr);        // размер массива в байтах
sizeof(*ptr);       // размер того, на что указывает указатель
```
Только не забудь — `sizeof` **не вызывает код**. Он вычисляется на этапе компиляции. То есть если ты туда пихнёшь функцию, её **не вызовет**.

`size_t` — тип без соплей
Это просто **тип без знака**, используемый для размеров, индексов, и всего того, что не должно быть отрицательным. По факту, это просто синоним для какого-нибудь `unsigned int` или `unsigned long` в зависимости от архитектуры.
```
#include <stdio.h>
int main ()
{
	int n = 0;
	size_t intsize;
	intsize = sizeof (int)
	printf("n = %d, n состоит из %zd байтов; все значения int имеют %zd байтов. \n", n, sizeof n, intsize );
}
```
> n = 0, n состоит из 4 байтов; все значения int имеют 4 байтов.

Почему использовать `size_t`, а не `int`?
Потому что `size_t` — **тот тип, который возвращает `sizeof`**. Он гарантированно может вместить в себя любой размер объекта в памяти.

```
int n = 0;
```
Ты создаёшь **переменную `n` типа `int`**, присваивая ей значение 0. Просто, чтоб потом было что напечатать. Это ничего не делает сверхъестественного, просто ебаный ноль лежит себе.

```
size_t intsize;

```
`intsize` — переменная типа `size_t`. Это такой **беззнаковый тип**, который используется **для хранения размеров объектов**. Тип возвращается оператором `sizeof`. Почему `size_t`? Потому что всякие ёбаные `int` могут не влезть, если ты решишь посчитать размер 10-гигового массива, долбоёб.

```
intsize = sizeof (int);

```
`sizeof(int)` вернёт **размер типа `int` в байтах**, и ты сохраняешь это в `intsize`. Обычно это будет **4 байта**, но может отличаться в зависимости от платформы. Например, на 16-битном старье `int` может быть 2 байта, на 64-битном — чаще 4.

**`sizeof`** нужен, чтобы узнать эти размеры? **`size_t`** же ты используешь для работы с ними. Это не "или-или", это **комплекс!** Без **`sizeof`** и **`size_t`** ты бы не знал, что вообще с памятью происходит.

А, ну если ты хочешь вывести это **чудо** на экран, то тебе нужно использовать **`printf`** с правильным форматом. Для **`size_t`** используется спецификатор **`%zu`**, не путай с **`%d`**!
```
#include <stdio.h>
int main()
{
    size_t intsize = sizeof(int);  // Размер типа int в байтах
    // Выводим размер переменной intsize
    printf("Размер типа int в байтах: %zu\n", intsize);
    return 0;
}
```

## Typedef
 Тип `typedef` в языке C используется для создания новых типов данных или псевдонимов для уже существующих типов. Например, можно использовать `typedef` для сокращения сложных типов данных или создания алиасов для типов данных, чтобы облегчить их использование
 ```
 typedef существующий_тип новый_тип;

```
Создание псевдонима для типа:
```
typedef unsigned int uint;
uint x = 10;  // uint теперь синоним для unsigned int
```
Для структур:
```
typedef struct {
    int x;
    int y;
} Point;

Point p1;  // Теперь можно использовать Point вместо struct

```
Для указателей:
```
typedef int* int_ptr;

int_ptr ptr;  // int_ptr - это указатель на int

```
`typedef` не создает новый тип данных в плане системы типов — он просто создает псевдоним для уже существующего типа.

## Выражения и операторы
Операторы формируют базовые шаги программы на С, и большинство операторов построено на основе выражений. 
Выражение состоит из комбинации операций и операндов(опе­ранд — это то , над чем выполняется операция.) Простейшим выражением является отдельный операнд , и он может служить отправной точкой для построения более сложных выражений .
```
4
-6
4+21
a*(b+c/d)/20
q = 5*2
x = ++q % 3
q > 3
```
Операнды могут быть константы, переменные и их сочетания. 

Важное свойство языка С заключается в том , что каждое **выражение** имеет значение. Чтобы найти это значение , нужно выполнить операции в порядке , определенном приоритетами операций.

**Операторы** служат основными строительными блоками программы. **Программа** - последовательность операторов с необходимыми знаками пунктуации. Оператор представляет собой завершенную инструкцию для компьютера. **Операторы распознаются по наличию точки с запятой**
```
legs = 4 <- выражение
legs = 4; <- Оператор
```

## составные операторы (блоки)
**Составной оператор** - два или большее кол-во операторов, сгруппированных вместе путём помещения их в фигурные скобки; так называют **блоком**
```
// #1
index = 0;
while (index++ < 10)
	sam = 10 * index + 2;
print("sam = %d\n", sam);
// #2
inddex = 0;
while (index++ < 10)
{
	sam = 10 * index + 2;
	printf("sam = %d\n", sam);
}
```
Внутри #1 в цикл while включен только оператор присваивания. В отсутствие фигурных скобок область действия оператора while распространяется от ключевого слова while до следующей точки с запятой. Функция printf() вызывается только один раз — по завершении цикла.

В #2 наличие фигурных скобок гарантирует, что оба оператора являются частью цикла while, а функция printf() вызывается при каждом выполнении цикла.
![[Pasted image 20250412192738.png]]
### Операция приведения
**Вы всегда должны избегать автоматического преобразования типов.**
```
mice = 1.6 + 1.7;
mice = (int) 1.6 + (int) 1.7;
```
В первой строке применяется автоматическое преобразование типов. Всё суммируется, усекается, чтобы соответствовать типу int.
Во второй строке числа 1.6 и 1.7 преобразуется в целочисленный вид, в результата присваевается 1+1, или 2. 
**НИ ОДНА ИЗ ЭТИ ФОРМ НЕ СЧИТАЕТСЯ ПРАВИЛЬНОЙ, НЕОБХОДИМО УЧИТЫВАТЬ КОНТЕКСТ. ЛУЧШЕ ЗАРАНЕЕ УКАЗАТЬ ТИП ДАННЫХ, БЕЗ ЭТИХ ДРОЧЕК:**
```
int mice = 1.6 + 1.7
```

# ГЛАВА 6 Управляющие операторы С: циклы
## while
Цикл while — это условный цикл, использующий входное условие (предусловие). Цикл называется “условным”, поскольку выполнение его операторной части зависит от условия, описанного условным выражением, таким как ( index < 5). Это выражение представляет собой предисловие, поскольку оно должно быть удовлетворено, прежде чем произойдет вход в тело цикла.
==Оператор while создает цикл, который повторяется до тех пор, пока проверочное выражение не станет ложным, или нулевым. Оператор while представляет собой цикл с предусловием; это значит, что решение относительно очередной итерации цикла принимается перед проходом. Следовательно, вполне возможно, что цикл вообще не будет выполнен. Операторная часть цикла может быть простым или составным оператором.==
```
#include <stdio.h>
  
int main()
{
    double num, sum;
    int choice = 0;
    printf("Введите первое число: ");
    choice = scanf("%lf", &num);
  
    while (choice == 1)
    {
        sum+=num;
        printf("Введите следущие числа для сложения\n(Для выхода используйте q): ");
        choice = scanf("%lf", &num);
    }
    printf("Сумма: %.2lf", sum);
    return 0;
}
```
Условием проверки этого цикла является следующее выражение:
```
while (choice == 1)
```
На каждой итерации в цикле текущее значение num добавляется к значению переменной sum, так что sum хранит промежуточную сумму. Когда переменная status получит значение, отличное от 1, цикл завершается, и программа выводит финальное значение sum

 Переменная num **не избыточна**, она **фундаментально необходима**, если ты хочешь СКЛАДЫВАТЬ значения, а не перезаписывать.

Чтобы цикл работал правильно, нужно каждый раз:
1. **Считать новое число в `num` с помощью `scanf()`**.
2. **Проверить, успешно ли прошёл ввод, используя возвращаемое значение `scanf()`**, которое сохраняется в `status`.
`scanf()` возвращает:
- `1`, если число считано успешно;
- `0`, если ввод не является числом (например, `q`);
- `EOF` (`-1`), если произошёл конец ввода или ошибка.
Если `scanf()` не возвращала бы статус, нельзя было бы удобно определить, когда завершить цикл (например, если человек ввёл `0` или отрицательное число — это валидный ввод, и нельзя по самому `num` понять, пора ли выходить).
**Главная фишка**: цикл останавливается не потому что число какое-то особенное, а потому что `scanf()` не смог считать корректный `double`.
🧠 **Вывод**: комбинация `status = scanf(...)` и переменной `num` позволяет:
- читать данные;
- проверять корректность;
- удобно завершать цикл при любом нечисловом вводе.
Вот и всё. Без `num` — код сдохнет. Без проверки `status` — получишь вечный цикл идиотии.

В любом случае, поскольку **while** является **циклом с предусловием**, **программа должна получить входные данные и проверить значение переменной status до того, как будет произведен вход в тело цикла**. Именно по этой причине в программе имеется вызов функции scanf () перед while. Чтобы цикл мог продолжаться, внутри него должен присутствовать оператор чтения, который позволит определить значение переменной status для следующего входного значения. В связи с этим оператор scanf() присутствует также в конце цикла while; он подготавливает цикл к следующей итерации.

Общая форма цикла while имеет следующий вид: 
```
while (выражение) 
	  оператор
```
Часть операто р может быть простым оператором, завершающимся точкой с запятой, либо составным оператором, заключенным в фигурные скобки.

Если выражение **истинно** (имеет ненулевое значение), то часть *оператор* выполняется один раз и затем выражение проверяется снова. Такой повторяющийся процесс проверки и выполнения повторяется до тех нор, пока выражение не станет ложным (нулевое значение). Каждый процесс проверки и выполнения называется *итерацией*
![[Pasted image 20250415104332.png]]
При построении цикла while должен быть предусмотрен код, который изменяет значение проверочного выражения, чтобы оно в конечном итоге стало ложным. В противном случае цикл никогда не закончится. (можно применить операторы break и if)
```
index = 1;
while (index < 5)
	printf("ZZZZVVVV\n");
```
Фрагмент программы выводит это ободряющее сообщение бесконечно. Потому что, цикл ничего не меняет и "index" всегда остаётся = 1. 
```
index = 1;
while (++index < 5)
	printf("ZZZZVVVV\n");
```
Эта версия кода обеспечит завершение цикла после того, как значение переменной index станет больше 5
### Когда цикл завершается?
Важно понимать, что решение прекратить или продолжить выполнение цикла принимается только после того, как вычислено условие проверки
```
#include <stdio.h>
int main(void)
{
int n = 5;
while (n++ < 7){
  
    printf("n = %d\n", n) ;
    n++; // строка 10
    printf("Теперь n = %d\n", n); // строка 11
}
printf("Цикл завершен.\n");
return 0;
}
```
n =5, пока она не достигнет значения > 7, цикл не завершится.

Для примера предположим, что вы хотите пропустить входные данные до первого символа, который не является пробельным или цифровым. Можно воспользоваться таким циклом:
```
while (scanf("%d", &num) == 1)
	;
```
Для ясности точка с запятой (пустой оператор) должна размещаться в следующей строке, а не вместе с оператором while. Это упрощает распознавание пустого оператора, а также напоминает о том, что он включен преднамеренно. Но еще лучше применять оператор continue.

### continue
`continue` — **перебрасывает выполнение сразу в следующую итерацию цикла**, нахуй игнорируя всё, что ниже в теле цикла.
 
```
while (scanf("%lf", &num) == 1)
{
    if (num < 0)
        continue; // идем сразу к следующему вводу

    sum += num;
}
```
Всё логично: если хуйня — идём дальше, если норм — добавляем. Всё читается как конфетка, компилятор тебя любит, читатель уважает, Бог прощает.
#### Зачем и когда юзать `continue`?
- Когда хочешь **пропустить остаток цикла** при каком-то условии.
- Когда **не хочешь вкладывать всё в `if/else`**, чтобы сохранить **чистый поток кода**.

Программа **принимает очки игр**, **проверяет их допустимость** (от 0 до 100), **находит минимальное, максимальное** и **считает среднее значение** всех введённых чисел.
```
#include <stdio.h>
int main(void)
{
    const double MINIMUM_SCORE = 0.0;
    const double MAXIMUM_SCORE = 100.0;
    double currentScore;
    double totalScore = 0.0;
    int gameCount = 0;
    double minimumScore = MAXIMUM_SCORE;
    double maximumScore = MINIMUM_SCORE;
  
    printf("Введите результат первой игры (или q для завершения): ");
    while (scanf("%lf", &currentScore) == 1)
    {
        if (currentScore < MINIMUM_SCORE || currentScore > MAXIMUM_SCORE)
        {
            printf("%.1lf - недопустимое значение. Повторите попытку: ", currentScore);
            continue;
        }
        printf("Принято значение %.1lf\n", currentScore);
        minimumScore = (currentScore < minimumScore) ? currentScore : minimumScore;
        maximumScore = (currentScore > maximumScore) ? currentScore : maximumScore;
        totalScore += currentScore;
        gameCount++;
        printf("Введите результат следующей игры (или q для завершения): ");
    }
  
    if (gameCount > 0)
    {
        printf("Среднее значение %d результатов равно %.1lf\n", gameCount, totalScore / gameCount);
        printf("Минимальное = %.1lf, максимальное = %.1lf\n", minimumScore, maximumScore);
    }
    else
        printf("Не было введено ни одного допустимого результата.\n");
  
    return 0

}
```
### 📦 Переменные:
`const float MIN = 0.0f; const float MAX = 100.0f;`
— **допустимые границы** результата: от `0.0` до `100.0`.
`float score;`
— сюда пишется **введённый пользователем результат** (одно число).
`float total = 0.0f;`
— суммарное значение всех допустимых результатов, чтобы потом вычислить **среднее**.
`int n = 0;`
— счётчик, сколько **допустимых результатов** введено.
`float min = MAX; float max = MIN;`
— здесь будут храниться **самые маленькие и самые большие** введённые числа.
- `min` начинается с **максимума**, чтобы любое введённое число было меньше.
- `max` — с **минимума**, чтобы любое число было больше.
### 🔁 Основной цикл:
`while (scanf("%f", &score) == 1)`
- Пользователь вводит число.
- Если это **не число** (например, `q`), `scanf` **вернёт не 1**, и цикл завершится.
### 🧼 Проверка допустимости:
`if (score < MIN || score > MAX)`
- Если число **меньше 0 или больше 100** — оно **нахуй не нужно**.
- Программа пишет: «Неправильно, пробуй снова».
### ✅ Если всё ок:
`printf("Accepting %.1f\n", score);`
— Пишет, что число принято.
```
min = (score < min) ? score : min; 
max = (score > max) ? score : max;
```
— Тернарниками обновляется минимум и максимум. Если текущее число меньше текущего `min`, то оно становится новым минимумом. Аналогично с `max`.
`total += score; n++;`
— Прибавляем очко к общей сумме, увеличиваем счётчик `n`.

### 📊 После цикла:
`if (n > 0)`
Если хотя бы одно **нормальное число введено**:
```
printf("Среднее значение %d результатов равно %.1f\n", n, total / n); 
printf("Минимальное = %.1f, максимальное = %.1f\n", min, max);
```
— Выводит среднее, минимум, максимум.
```
else     
	printf("Не было введено ни одного допустимого результата.\n");
```
— Если **всё говно** — пишет, что ты вообще **ни одного нормального числа не ввёл**.

Почему в `min` кладём `MAX`, а в `max` — `MIN`?
```
float min = MAX;
```
Ты хочешь найти **наименьшее** из всех введённых значений. Чтобы это сделать, тебе нужно сравнивать каждое новое значение с текущим минимумом.  
Если ты начнёшь с нуля (`float min = 0.0f;`), то:
- Ты **никогда не получишь результат меньше**, если все введённые числа положительные — ничего не изменится, даже если введёшь 5, 10, 50.
- В итоге `min` так и останется 0.0, даже если никто не вводил 0.
А вот если ты начнёшь с **высшего возможного значения** (`100.0`), то **любое реальное значение будет меньше**, и `min` нормально обновится.
**То же самое с `max`:**
`float max = MIN;`
Ты хочешь найти **максимум**. Если начнёшь с `100`, ты не найдёшь ничего больше — потому что это и так максимум. Всё будет меньше, и `max` останется в говне.
А вот если начнёшь с **нуля**, то:
- Любое реальное значение больше 0 перезапишет `max`.
- И вуаля — ты находишь реальный максимум из введённых значений.

Пример
```
float min = 0.0f; // <- хуйня
float max = 100.0f; // <- тоже хуйня
```
Ввёл числа: `20.0`, `50.0`, `90.0`
- `min` останется **0.0** (а ты такого даже не вводил).
- `max` останется **100.0** (а его ты тоже не вводил).
Правильно
```
float min = 100.0f; // максимум границы
float max = 0.0f;   // минимум границы
```
Ввёл `20.0`, `50.0`, `90.0`:
- `min` будет 20.0
- `max` будет 90.0
Короче, это **инициализация с крайними значениями**, чтобы **первое же валидное число** точно обновило `min` и `max`.

---
Поскольку циклы while часто полагаются на проверочные выражения, которые делают сравнения(Такие выражения называются вырежниями отношений, а операции, которые в них появляются — операции отношений).

| Операция | Чо               |
| -------- | ---------------- |
| <        | Меньше           |
| <=       | Меньше или равно |
| ==       | Равно            |
| >=       | Больше или равно |
| >        | Больше           |
| !=       | Не рвно          |
Операции отношений применяются для построения выражений отношения, используемых в операторах while.
Функция fabs(), объявленная в заголовочном файле math.h, может быть удобной при проверках, в которых участвуют числа с плавающей запятой:
```
#include <stdio.h>
#include <math.h>
int main ()
{
    const double ANSWER = 3.14159;
    double response;
    printf("Каково значение числа pi?: ");
    scanf("%lf", &response);
    while (fabs(response - ANSWER) > 0.0001)
{
    printf("Bвeдитe значение еще раз: ");
    scanf("%lf", &response);
}
    printf("Достаточно близко!\n");
    return 0;
}
```
> Каково значение числа pi?: 3.14
Bвeдитe значение еще раз: 3.1415
Достаточно близко!

## _bool_
В программировании переменные, представляющие истинные и ложные значения, известны как булевские. Переменная типа Bool может иметь только значения 1 (“истина”) и 0 (“ложь”)

```
#include <stdio.h>

#include <math.h>
int main ()
{
    long num;
    long sum = 0;
    _Bool input_is_good;
    printf("Введите целое число: ");
    input_is_good = (scanf("%ld", &num) == 1);
    while (input_is_good)
    {
        sum+=num;
        printf("Введите след. число: ");
        input_is_good = (scanf("%ld", &num) == 1);
    }
    printf("Сумма: %ld", sum);
    return 0;
}
```
результат сравнения переменной:
```
input_is_good = (scanf("%ld", &num) == 1);
```
Такое присваивание имеет смысл, поскольку операция == возвращает значение 1 или О

Можно подключить <stdbool.h>, где вместо 0 и 1 используется True и False.
## Цикл for
```
int main ()
{
    const int NUMBER = 22;
    int count;
    for(count = 1; count <= 100; count++)
        printf("Пошёл нахуй\n ");
    return 0;
}
```
Первое выражение — это инициализация. Она осуществляется только один раз при первом запуске цикла for. Второе выражение представляет собой условие проверки; оно вычисляется перед каждым потенциальным проходом цикла. Третье выражение, которое выполняет изменение или обновление, вычисляется в конце каждой итерации.

```
#include <stdio.h>
  
int main()
{
    int number;
    printf("Введите число: ");
    scanf("%d", &number);
    for (int i = 1; i <= number; i++){
        if(i % 2 == 0) {
            printf("число %d четное\n", i);
        } else{
            printf("число %d нечетное\n", i);
        }
    }
    return 0;
}
```
- `number` — это конечная граница (`i <= number`)
- `i` — это текущее число, которое надо проверить на чётность и вывести.
![[Pasted image 20250415122110.png]]

Таблица кубов
```
#include <stdio.h>
  
int main()
{
    int number;
    printf("Таблица кубов:\n");
    printf("    n    n^3\n");
    for(number = 1; number <= 9; number++) {
        printf("%5d %5d\n", number, number*number*number);
    }
    return 0;
}
```

```
#include <stdio.h>
  
int main()
{
    int secs;
    for(secs = 5; secs > 0; secs--){
        printf("%d секунд(ы)\n", secs);
    }
    printf("Машина заведена");
    return 0;
}
```

```
#include <stdio.h>

int main()
{
    char ch;
    for(ch = 'a'; ch <= 'z'; ch++){
        printf("Значение ASCII для %c = %d.\n", ch, ch);
    }
    return 0;
}
```
С 219 стр
В операторе for используются три управляющих выражения, разделяемые точками с запятой. Выражение инициализация вычисляется однократно до выполнения любых операторов внутри цикла. Затем вычисляется выражение проверка , и если оно истинно (или не равно нулю), то тело цикла выполняется один раз. Далее вычисляется выражение обнов­ление , после чего снова вычисляется выражение проверка. Оператор for представляет собой цикл с предусловием — решение о проходе цикла еще раз принимается перед входом в него. Таким образом, вполне возможно, что цикл не выполнится ни разу. Часть оператор может быть простым или составным оператором.
```
for (инициализация; проверка; обновление){
	оператор;
}
```

```
for (n=0;n<10;n++){
	printf(" %d %d\n", n, 2 * n + 1);
}
```

### Дополнительные операции присваивания: +=, -=, (D*)=, /=, %=
```
scores += 20 — то же, что и scores = scores + 20
dimes - = 2 — то же, что и dimes = dimes - 2
bunnies *= 2 — то же, что и bunnies = bunnies * 2 
time /= 2.73 — то же, что и time = time / 2.73 
reduce %= 3 — то же, что и reduce = reduce %
х *= 3*у+12 — то же, что и х=х*(3*у+12)
```

## Греческий философ Зенон и цикл for
**Зенон говорил:** стрела никогда не долетит до цели, потому что сначала она пролетает половину пути, потом половину оставшегося, потом ещё половину, и так бесконечно. Раз путь делится на бесконечно много частей — значит, и времени на это нужно бесконечно.
Применим количественный подход и предположим, что стреле требуется одна секунда, чтобы пролететь первую половину пути. Затем ей понадобится 1/2 секунды, чтобы пролететь половину оставшегося пути, еще 1/4 секунды, чтобы преодолеть половину пути, который остался после этого, и т.д.
**Но на самом деле:** даже бесконечно много всё меньших промежутков могут в сумме дать конечное число. Например:
```
1 + 1/2 + 1/4 + 1/8 + 1/16 ... 
```
То есть, если первая часть пути занимает 1 секунду, следующая — 0.5 секунды, потом 0.25 и т.д., то суммарное время будет **2 секунды**, а не бесконечность.

программа вычисляет сумму нескольких первых элементов этой последовательности. Переменная power_of_two принимает значения 1.0, 2.0, 4.0, 8.0 итд.
```
#include <stdio.h>
int main (void)
{
    int t_ct; // счетчик элементов
    double time, power_of_2;
    int limit;
    printf("Введите желаемое количество элементов последовательности: ");
    scanf("%d", &limit);
    for (time=0, power_of_2=1, t_ct=1; t_ct <= limit;
                                t_ct++, power_of_2 *= 2.0)
    {
    time += 1.0/power_of_2;
    printf("время = %f, когда количество элементов = %d.\n", time, t_ct);
    }
    return 0;
}
```
> Введите желаемое количество элементов последовательности: 13
время = 1.000000, когда количество элементов = 1.
время = 1.500000, когда количество элементов = 2.
время = 1.750000, когда количество элементов = 3.
время = 1.875000, когда количество элементов = 4.
время = 1.937500, когда количество элементов = 5.
время = 1.968750, когда количество элементов = 6.
время = 1.984375, когда количество элементов = 7.
время = 1.992188, когда количество элементов = 8.
время = 1.996094, когда количество элементов = 9.
время = 1.998047, когда количество элементов = 10.
время = 1.999023, когда количество элементов = 11.
время = 1.999512, когда количество элементов = 12.
время = 1.999756, когда количество элементов = 13.

Легко заметить, что хотя мы и добавляем все новые элементы, общая сумма, по-видимому, не превысит некоторой величины. И в самом деле, математики доказали, что сумма этой последовательности стремится к 2.0 по мере того, как количество просуммированных элементов стремится к бесконечности

Предположим, что S представляет собой такую сумму:
```
S = 1 + 1/2 + 1/4 + 1/8 + ...
```
Здесь многоточие означает “и т.д.”. Разделив S на 2, получаем:
```
S/2 = 1/2 + 1/4 + 1/8 + 1/16 + ...
```
Вычитание второго выражения из первого дает:
```
S - S/2 = 1 + 1/2 - 1/2 + 1/4 - 1/4 + ...
```
За исключением начального значения 1 все остальные значения образуют пары, в которых одно значение положительное, а второе — отрицательное, так что эти элементы уничтожают друг друга, в результате оставляя:
```
S/2 = 1
```
И, наконец, умножение обеих сторон на 2 дает:
```
S = 2 
```
Прежде чем начинать сложные вычисления, проверьте, не нашли ли математики более простого способа делать это. Что можно сказать о самой программе? Она показывает, что в выражении можно использовать более одной операции запятой. Вы инициализировали переменные time, power_of_2 и count. После того, как вы определили условия для цикла, программа оказалась совсем короткой.

## Цикл с постусловием: do while
Циклы while и for являются циклами с предусловием. Условия проверки вычисляются перед каждой итерацией цикла, поэтому вполне возможно, что операторы, помещенные в цикл, никогда не выполнятся. 
```
#include <stdio.h>
  
int main()
{
    const int secret_code = 1488;
    int entered_code;
  
    do
    {
        printf("Чтобы войти в рехаб, введите KEY: ");
        scanf("%d", &entered_code);
  
    } while (entered_code != secret_code);
    printf("Давай не заёбывай!");
    return 0;
}
```
> Чтобы войти в рехаб, введите KEY: 13
Чтобы войти в рехаб, введите KEY: 14
Чтобы войти в рехаб, введите KEY: 15
Чтобы войти в рехаб, введите KEY: 16
Чтобы войти в рехаб, введите KEY: 188
Чтобы войти в рехаб, введите KEY: 148
Чтобы войти в рехаб, введите KEY: 1488
Давай не заёбывай!

Либо можно переписать под While
```
#include <stdio.h>
  
int main()
{
    const int secret_code = 1488;
    int entered_code;
  
    while (entered_code != secret_code) {
        printf("Чобi войти в рехаб, введите пiроль: ");
        scanf("%d", &entered_code);
    }
    printf("Давай не заёбывай!");
    return 0;
}
```

Общая форма do while:
```
do 
	оператор
while ( выражение );
```
**Оператор может быть простым или составным. Обратите внимание на то, что сам цикл do while считается оператором и таким образом требует наличия после него точки с запятой**.
![[Pasted image 20250416212411.png]]
Например, программа запроса пароля могла бы содержать цикл, как демонстрируется в следующем псевдокоде:
```
do 
{
	Запрос пароля
	Прочитать введенный пароль
} while(введенные данны не совпадают с паролем);
```
**Избегайте применения структуры do while, которая имеет вид, подобный показанному ниже псевдокоду:**
```
do
{
	запросить пароль, желает ли он продолжить
	какие-то действия
} while(ответом является 'да');
```
**В этом случае, даже если пользователь ответит “нет” на запрос о продолжении, действия вес равно выполняются, т.к. проверка введенного ответа происходит слишком поздно.**

Оператор do while создает цикл, который повторяется до тех пор, пока проверочное выражение не станет ложным или нулевым. Оператор do while является циклом с постусловием, т.е. решение о следующем проходе цикла принимается после выполнения текущей итерации. Таким образом, цикл должен быть выполнен, по меньшей мере, один раз. Часть оператор может быть простым или составным оператором.

## Выбор подходящего цикла
Предположим, что требуется цикл с предусловием. Это должен быть цикл for или же цикл while? Частично это дело вкуса, поскольку то, что возможно сделать с помощью одного цикла, можно достичь и посредством другого. Чтобы сделать цикл for похожим на while, можно не указывать первое и третье выражения. Так, цикл
```
for (; Условие-проверки ;)
```
=
```
while(условие-проверки)
```
Чтобы придать циклу while вид, подобный for, предварите его инициализацией и предусмотрите внутри тела операторы для обновления значений
```
инициализация;
while(условие-проверки)
{
	тело-цикла;
	обновление;
}
```
=
```
for (инициализация; условие-проверки; обновление)
	тело цикла;
```
С позиций преобладающего стиля цикл for больше подходит в ситуациях, когда цикл предусматривает инициализацию и обновление переменной, а цикл while предпочтительнее, когда этого делать не нужно. Цикл while целесообразно применять для следующего условия:
```
while (scanf("%ld", &num) == 1)
```
Цикл for является более естественным выбором, когда реализуется подсчет для какого-нибудь индекса:
```
for (count = 1; count <= 100; count++)
```

## Вложенные циклы
Вложенный цикл — это цикл внутри другого цикла. Вложенные циклы часто используются для отображения данных в виде строк и столбцов. Один цикл может обрабатывать, скажем, все столбцы в строке, а второй цикл - все строки.
```
#include <stdio.h>
  
#define ROWS 6
#define CHARS 10
  
int main (void)
{
    int row;
    char ch;
    for(row = 0; row < ROWS; row++)
    {
        for(ch = 'A'; ch < ('A' + CHARS); ch++)
            printf("%c", ch);
        printf("\n");
    }
    return 0;
}
```
> ABCDEFGHIJ
ABCDEFGHIJ
ABCDEFGHIJ
ABCDEFGHIJ
ABCDEFGHIJ
ABCDEFGHIJ

Внешний цикл стартует при значении 0 переменной row и завершается, когда ее значение достигает 6. Таким образом, происходит шесть итераций внешнего цикла, и переменная row последовательно получает значения от 0 до 5. Первый оператор в каждой итерации является внутренним циклом for. Он выполняет 10 итераций, выводя символы от А до J в одной строке. Второй оператор внешнего цикла, printf( "\n") ; , начинает новую строку, так что при следующем выполнении внутреннего цикла вывод будет производиться в новой строке.

## Введение в массивы
Массивы являются важным инструментом во многих программах. Они позволяют хранить несколько элементов связанной информации в удобной форме. Массив — это совокупность значений одного и того же типа, которые хранятся в памяти последовательно. Массив целиком носит свое имя, а доступ к его отдельным элементами осуществляется с применением целочисленного индекса
```
#include <stdio.h>

  
int main (void)
{
    char array[] = {1,2,3,4,5,6,7};
    for (int i = 0; i < sizeof(array); i++){
        printf("%d", array[i]);
    }
    return 0;
}
```
char array[] = {1,2,3,4,5,6,7}; - Создание массива, где компилятор сам считает какое ограничение надо сделать по символам. В {} указаны числа;
Вывод через for, где ограничение(второй операнд) - вычисляется через sizeof(**возвращает размер массива в байтах: 1 символ - 1 байт, в примере получаем 7 байт - 7 символов** ).

Нумерация элементов массива начинается с 0, а не с 1. 
Каждому элементу массива может быть присвоено значение float:
```
debts[4] = 3,14;
```
В сущности, элемент массива можно использовать тем же самым образом, как это делалось бы с переменной такого же типа. Например, можно прочитать значение и поместить его в конкретный элемент:
```
scanf("%f", &debts[4]); //чтение значения в 5-й элемент массива
```

```
#include <stdio.h>
  
int main(void)
{
    int size, sum = 0;
    printf("Введите кол-во элементов в кошельке: ");
    if(scanf("%d", &size) != 1 || size <= 0) {
        printf("Че пиздишь??\n");
        return 1;
    }
  
    int wallet[size];
    printf("Окей, размер кошелька = %d\n", size);
    printf("Теперь заполните этот кошелек:\n");
  
    for (int i = 0; i < size; i++) {
        printf("Элемент %d: ", i + 1);
        scanf("%d", &wallet[i]);
        sum += wallet[i];
    }
  
    printf("Так, так, так... Твой кошелек имееет столько денег:\n");
    for (int i = 0; i < size; i++) {
        printf("%d ", wallet[i]);
    }
  
    printf("\nЭто: %d долларов\n", sum);
  
    return 0

}
```
> Введите кол-во элементов в кошельке: 3
	Окей, в твоей кошелке: 3 элементов
	Теперь заполним ваш кошелек деньгами:
	Элемент 1: 4
	Элемент 2: 5
	Элемент 3: 6
	ОГО!
	4 5 6
	А это.... 15 долларов

Работать с массивами и циклами гораздо удобнее, чем применять 10 операторов scanf() и 10 операторов printf() для чтения и вывода 10 результатов. Цикл for предлагает простой и прямолинейный способ использования индексов массива. 
Следует отметить, что элемент массива int обрабатывается подобно переменной типа int. **Для чтения переменной fue типа int применялся бы вызов scanf("%d", &fue). В программе выше считывается элемент wallet[size] типа int, поэтому используется вызов scanf("%d", &wallet (size)).**

## Пример цикла. использующего возвращаемое значение функции
Мы сохраним функцию простой, ограничив ее положительными целочисленными степенями. Тогда для возведения числа п в степень р переменную n нужно просто умножить на саму себя p раз. Это совершенно естественная задача для цикла. Вы можете установить переменную pow в 1, после чего многократно умножать ее на n:
```
for(i=1; i <= p; i++)
	pow *=n;
```
Теперь, когда построен алгоритм, мы можем решить, какие типы данных исполь-зовать. Показатель степени р, будучи целочисленным, должен иметь тип int. Чтобы обеспечить достаточный диапазон значений для переменной n и ее степеней, выбе-рем для переменных n и pow тип double.
Давайте далее обдумаем, как оформить функцию. Нам необходимо предоставить функции два значения, а она должна возвратить одно значение. Чтобы передать фун-кции необходимую информацию, можно определить два аргумента, один типа double и один типа int, указывающие число и степень. Как обеспечить возвращение функ-цией значения в вызывающую программу? Для написания функции с возвращаемым значением выполните следующие действия.
1. При определении функции установите тип значения, которое она возвращает. 
2. С помощью ключевого слова return укажите возвращаемое значение.
```
double power (double n, int p) // returns type double
{
	double pow = 1;
	int i;
	for (i = 1; i <= p; i++)
	pow *= n;
	return pow;
	// return the value of the variable pow
}
```
Чтобы объявить возвращаемый тип функции, предварите этим типом имя функ-ции, как это делается при объявлении переменной. Ключевое слово return заставля-ет функцию возвратить в вызывающую функцию значение, указанное после return. Здесь функция возвращает значение переменной, но она может также возвращать зна-чения выражений. Например, следующий оператор вполне допустим:
``return 2* x + b;``

Функция вычислит значение выражения и возвратит его. В вызывающей функ-ции возвращаемое значение может быть присвоено другой переменной, использова-но как значение выражения, передано в качестве аргумента другой функции (как в printf("%f", power (6.28, 3))) или просто проигнорировано.

Теперь давайте применим функцию в программе. При тестировании функции было бы удобно располагать возможностью передачи этой функции нескольких зна-чений, чтобы увидеть, как она реагирует. Это предполагает настройку цикла ввода. Естественным вариантом является цикл while. Функцию scanf() можно использо-вать для ввода двух значений одновременно. Если функция scanf() успешно про-читает два значения, она возвратит 2, поэтому циклом можно управлять, сравнивая возвращаемое значение scanf() со значением 2. Еще один момент: чтобы воспользо ваться функцией power () в программе, ее понадобится объявить, как вы объявляете применяемые в программе переменные.

```
#include <stdio.h>
#include <math.h>
  
double power(double n, int p) {
    double pow = 1;
    for (int i = 1; i <= p; i++) {
        pow *= n;
    }
    return pow;
}
  
int main() {
    double x, exp, xpow;
  
    printf("Введите число: ");
    if (scanf("%lf", &x) != 1) {
        printf("Че, еблан? Надо было число!\n");
        return 1;
    }
  
    printf("Введите степень: ");
    if (scanf("%lf", &exp) != 1) {
        printf("Ты совсем охуел? Где степень, мразь?\n");
        return 1;
    }
  
    xpow = power(x, (int)exp);
    printf("%.2lf в степени %d = %.2lf\n", x, (int)exp, xpow);

  
    return 0

}
```
>> Введите число: 3
	Введите степень: 4
	3.00 в степени 4 = 81.00
	Q - quit
	ПОШЁЛ НАХУЙ

## Использование цикла for с массивами
За счет использования массива вы избегаете необходимости объявлять 10 переменных с разными именами, по одной для каждого результата.
Кроме того, для чтения входных данных можно применять цикл for. 
Программа предназначена для подсчета общей суммы результатов, их среднего значения и гандикапа, который представляет собой разность между средним и стандартным результатом, или паром
```
#include <stdio.h>

#define SIZE 10
#define PAR 72
  
int main()
{
    int index, score[SIZE];
    int sum = 0;
    double average = 0.0;
  
    printf("Введите %d результатов игры в гольф:\n", SIZE);
    for (index = 0; index < SIZE; index++)
        scanf("%d", &score[index]); // чтение 10 результатов игры в гольф
    printf("Введены следующие результаты:\n");
    for (index = 0; index < SIZE; index++)
        printf("%5d", score[index]); // проверка введенной информации
    printf("\n");
    for (index = 0; index < SIZE; index++)
        sum += score[index]; // сложение результатов
    average = (double) sum / SIZE; // проверенный временем метод
    printf("Сумма результатов = %d, среднее значение = %.2lf\n", sum, average);
    printf("Полученный гандикап равен %.0lf.\n", average - PAR);
    return 0;
}
```
> Введите 10 результатов игры в гольф:
10 20 30 40 50 60 70 80 90 100
Введены следующие результаты:
   10   20   30   40   50   60   70   80   90  100
Сумма результатов = 550, среднее значение = 55.00
Полученный гандикап равен -17.

Работать с массивами и циклами гораздо удобнее, чем применять 10 операторов scanf () и 10 операторов printf () для чтения и вывода 10 результатов. Цикл for предлагает простой и прямолинейный способ использования индексов массива. Следует отметить, что элемент массива int обрабатывается подобно переменной типа int. Для чтения переменной fue типа in t применялся бы вызов scanf ("%d", & fue). В листинге 6.19 считывается элемент score [index] типа int, поэтому используется вызов scanf("%d", &score[index]) .

Во-первых, применение директивы #define для создания символической константы (SIZE), указывающей размер массива, является хорошей идеей. Эта константа используется в определении массива и при установке пределов в циклах. Если позже понадобится расширить программу для обработки 20 результатов, достаточно просто переопределить константу SIZE, сделав ее равной 20. Вам не придется изменять каждую часть программы, в которой участвует размер массива. Во-вторых, конструкция

```
for(index = 0; index < SIZE; i++)
```
Удобна для обработки массива с размером SIZE. Очень важно указывать правильные пределы массива. Первый элемент имеет индекс 0, и цикл начинается с установки index в 0. Поскольку нумерация начинается с 0, индексом последнего элемента является SIZE - 1. То есть десятый элемент массива — это score[9]. **Условие проверки index < SIZE обеспечивает это, делая последним применяемым значением index величину SIZE - 1**

В-третьих, в программах рекомендуется выводить на экран значения, которые были только что прочитаны (для эхо-контроля). Это помогает удостовериться в том, что программа обрабатывает именно те данные, которые ожидаются. 
В-четвертых, обратите внимание на использование трех отдельных циклов for. Вас может интересовать, действительно ли это необходимо. Можно ли объединить некоторые из операций в один цикл? **Да**, вы могли бы поступить так. Программа стала бы компактнее. Однако это противоречило бы принципу модульности . Идея, лежащая в основе этого термина, заключается в том, что программа должна быть разбита на отдельные модули, и каждый модуль должен решать одну задачу. Это облегчает чтение профаммы. Но что вероятно **даже важнее — модульность намного упрощает обновление или модификацию программы, потому что ее части не перемешаны. Когда вы обретете достаточные знания о функциях, то сможете поместить каждый модуль в функцию, улучшая модульность программы.**
## Использование функций с возвращаемыми значениями
Объявление, вызов и определение функции, а также применение ключевого слова return - все это базовые элементы в определении и использовании функции с возвращаемым значением
1. **Объявление (prototype)**  
    – Говорит компилятору: «Вот есть функция с таким-то именем, такими-то параметрами и типом возвращаемого значения».  
    – Нужно, если определение функции идёт ниже по коду или в другом файле, чтобы компилятор сразу «знал», как с ней обращаться.
2. **Определение (definition)**  
    – Содержит сам код функции — её «тело».  
    – Без объявления определение всё равно даёт компилятору всю информацию, но только после того, как он до него «докопается» в исходниках.
3. **Ключевое слово `return`**  
    – Завершает выполнение функции и передаёт вызывающему коду значение указанного типа.  
    – Если функция объявлена как возвращающая, например, `double`, то без `return` вы не сможете получить это значение.
- **Почему `scanf` не нужно объявлять вручную?**  
    Потому что вы включаете заголовок `#include <stdio.h>`, а в нём уже есть декларация `int scanf(const char *, …);`. Компилятор «знает» о `scanf` заранее.
- **Почему нужно объявлять свою `power`, если её определение ниже?**  
    Пока вы внутри `main` вызываете `power`, компилятор ещё не встретил её определение, и без предварительного объявления он не знает, какого типа у неё результат и сколько аргументов ждать.
- **Можно ли обойтись без объявления?**  
    Да — если определить функцию _до_ её первого применения. Но по стилю обычно ставят `main` первым, а вспомогательные функции — ниже или в отдельных файлах, поэтому объявления (`.h`-файлы или прототипы сверху) обязательны.
В итоге:
- Объявление сообщает интерфейс функции.
- Определение даёт реализацию.
- `return` отдаёт результат этой реализации обратно туда, откуда функция была вызвана.

Ключевые понятия
Цикл представляет собой мощный инструмент программирования. При написании цикла вы должны обращать особое внимание на следующие три аспекта.
1. Четкое определение условия прекращения цикла.
2. Обеспечение инициализации значений, задействованных в условии проверки цикла, перед первым их использованием.
3. Обеспечение в цикле действий по обновлению условия проверки на каждой итерации.
Условия проверки обрабатываются путем их числовой оценки. Результат, равный 0, трактуется как ложное значение, а любое другое числовое значение — как истинное. Выражения с операциями отношений часто выступают в качестве условий проверки и являются чуть более специфичными. Результатом такого выражения будет 1, сели оно истинно, и 0, если ложно, что соответствует значениям, разрешенным для нового тина Bool

Массивы состоят из расположенных рядом ячеек памяти со значениями одного и того же типа. Вы должны помнить, что нумерация элементов массива начинается с 0, поэтому последний элемент массива имеет индекс на единицу меньше количества элементов. В С не выполняется проверка допустимости значений индексов, так что ответственность за это возлагается целиком на вас.
**Использование функций включает три отдельных шага.** 
1. Объявление функции посредством ее прототипа. 
2. Выполнение функции внутри программы путем ее вызова. 
3. Определение функции.
Прототип позволяет компилятору проверять, корректно ли применяется функция, а определение функции указывает, как она должна работать. Прототип и определение функции являются примерами современного стиля программирования, предусматривающего разделение элемента программы на интерфейс и реализацию. Интерфейс описывает, как используется средство, что и делает прототип, а реализация далее расписывает конкретные действия, чем занимается определение функции.

Резюме
239

# ГЛАВА 7. Управляющие операторы С: ветвление и переходы 
```
#include <stdio.h>
  
int main() {
    const int FREEZING = 0;
    double temperature;
    int cold_days = 0, all_days = 0;
    printf("Введите список мин. дневных температур.\n");
    printf("Используйте шкалу Цельсия; Для завершения введите q.\n");
  
    while(scanf("%lf", &temperature) == 1) {
        all_days++;
        if(temperature < FREEZING)
            cold_days++;
    }
    if(all_days != 0)
        printf("Процент холодных дней: %.2f%%\n", 100.0 * cold_days / all_days);
    if(all_days == 0) {
        printf("Данные ввдены неверно.\n");
        return 0;
    }
}
```
Здесь мы создаем константу ХОЛОД равную 0
Потом создаем переменную в которую будем вводить температуру.\
Объявляем cold_days и all_days и приравниваем 0, т.к ключ.
В While проверяем, чтобы при вводе temperature удовлетворяло условию - только с плавающей запятой числа и если введём любое, но не число с плавающей запятой, то нас выкинет.
И добавляем всего дней + 1, потом проверяем, если температура меньше FREEZING(0), то добавляем 1 к cold_days
И если не равно 0, то высчитываем процент.

## getchar и putchar
**`getchar()`** — эта функция используется для того, чтобы считать один символ с клавиатуры. Когда ты вызываешь `getchar()`, программа приостанавливается, пока ты не нажмешь клавишу, и возвращает символ, который ты ввел. Это может быть как буква, так и цифра, пробел или любой другой символ.

```
ch = getchar();
```
Это будет тоже самое что и:
```
scanf("%c", &ch);
```

```
#include <stdio.h>

int main() {
    char c = getchar();  // Считывает один символ с клавиатуры
    printf("Ты ввел: %c\n", c);  // Выводит этот символ
    return 0;
}
```
>A
Ты ввел: A


**`putchar()`** — эта функция выводит один символ на экран. Ты передаешь ей символ, и она выводит его на экран. Это может быть полезно, если ты хочешь вывести какой-то символ, строку или результат вычислений в виде одиночных символов.
```
#include <stdio.h>

int main() {
    putchar('A');  // Выводит букву A на экран
    return 0;
}
```
Либо
```
#include <stdio.h>

int main() {
    char ch = 'P';
    putchar(ch);
    return 0;
}
```
- `getchar()` блокирует выполнение программы до тех пор, пока пользователь не введет символ.
- `putchar()` сразу выводит символ на экран, и выполнение программы продолжается.

Программа которая отображает введенную строку, но заменяет каждый отличный от пробела символ следую-щим за ним символом в последовательности кодов ASCII. Пробелы будут выводиться без изменений. Результат можно сформулировать так: "Если символ является пробе-лом, он выводится, в противном случае выводится символ, следующий за ним в после-довательности кодов ASCII".
```
  
#define SPACE ' '
  
int main() {
    char ch = getchar();
  
    while(ch != '\n')
    {
        if(ch == SPACE)
            putchar(ch);
        else
           putchar(ch+1);
        ch = getchar();
    }
    putchar(ch);
    return 0;
}
```

## Семейство функций для работы с символами ctype.h
Файл заголовка `<ctype.h>` в C — это просто кладбище функций для работы с ебучими символами:
- **`int isalnum(int c)`** — проверяет, ебать, буква это или цифра.
- **`int isalpha(int c)`** — проверяет, буква ли это вообще, а не твой кривой ввод.
- **`int isblank(int c)`** — проверяет, не ебаный ли это пробел или табуляция.
- **`int iscntrl(int c)`** — проверяет, управляющий ли это ёбаный символ, типа `\n` или `\t`.
- **`int isdigit(int c)`** — проверяет, что это ебаная цифра от 0 до 9, а не то говно, что ты обычно пишешь.
- **`int isgraph(int c)`** — проверяет, можно ли, сука, этот символ напечатать (но пробел не считается, нахуй он нужен).
- **`int islower(int c)`** — проверяет, маленькая ли это сраная буква.
- **`int isprint(int c)`** — печатный ли это символ, включая ёбаный пробел.
- **`int ispunct(int c)`** — проверяет, знак ли это препинания, типа твоих бесконечных запятых в тупых текстах.
- **`int isspace(int c)`** — проверяет, белый ли это пробельный символ (все виды, от пробела до новой строки).
- **`int isupper(int c)`** — проверяет, блядь, большая ли это буква.
- **`int isxdigit(int c)`** — проверяет, шестнадцатеричная ли это пиздюлина (`0-9`, `a-f`, `A-F`).
- **`int tolower(int c)`** — опускает твою ебаную заглавную букву в нижний регистр.
- **`int toupper(int c)`** — поднимает ссаную маленькую букву в верхний регистр.

```
#include <ctype.h>
#include <stdio.h>

int main() {
    char ch = 'A';
    if (isalpha(ch)) {
        printf("%c — это буква\n", ch);
    }
    printf("%c в нижнем регистре: %c\n", ch, tolower(ch));
    return 0;
}

```
> A — это буква
A в нижнем регистре: a

```
#include <ctype.h>
#include <stdio.h>
  
int main() {
    char ch;
    while((ch = getchar()) != '\n')
    {
        if(isalpha(ch))
            putchar(ch+1);
        else
            putchar(ch);
    }
    putchar(ch);
    return 0;
}
```
> ABCDEFGH
BCDEFGHI
14889
14889

## Сводка: использование операторов if для реализации выбора 
**Ключевые слова:** 
if else
**Общий комментарий:**
В каждой из приведенных ниже форм конструкция оператор может быть простым или со-ставным оператором. Истинным является выражение, имеющее ненулевое значение.
**Форма 1:**
if (выражение)
	оператор
оператор выполняется, когда выражение принимает истинное значение.
**Форма 2**
if (Выражение)
	оператор1
else 
	оператор2
Если выражение истинно, выполняется оператор1, в противном случае оператор2.
**Форма 3**
if (выражение1)
	оператор1
else if(выражение2)
	оператор2
else
	оператор3
Если выражение 1 истинно, выполняется оператор1. Если выражение1 ложно, но выражение2 истинно, выполняется оператор2. Если оба выражения ложны, выполняется оператор3.

## Давайте будем логичными
Временами возникает необходимость в объединении двух и более выражений. Например, предположим, что требуется программа, которая подсчитывает во введенном предложении количество символов, отличных от одиночных и двойных кавычек. В данном случае можно использовать логические операции и символ точки (.) для идентификации конца предложения.
```
#include <stdio.h>
#define PERIOD '.'
int main() {
    char ch;
    int charcount = 0;
    printf("Введите текст (закончите точкой '.'): ");
    while ((ch = getchar()) != PERIOD && ch != EOF) {
        if (ch != '"' && ch != '\'') {
            charcount++;
        }
    }
    printf("\nThere are %d characters other than quotes.\n", charcount);
    return 0;
}
```
> Rakom ded ebet  kobily "Dada".
There are 27 characters other than quotes.

Действие начинается с чтения символа и проверки, не является ли этот символ точкой, поскольку точка обозначает конец предложения. Далее появляется кое-что новое: в операторе присутствует логическая операция “И” — &&. Оператор i f можно трактовать так: если символ не является двойной кавычкой И не является одиночной кавычкой, то увеличить значение charcount на 1.
**Вот, что этот код делает:**
1. **Подключаем `<stdio.h>`**  
    — чтоб вообще иметь возможность пользоваться `printf`, `getchar`, и не выглядеть полным ублюдком, который забыл заголовок.
2. **Создаём макрос `PERIOD`, равный `'.'`**  
    — чтобы не писать тупо точку в коде, а иметь красивую константу (`PERIOD`).  
    Ну чисто чтобы казаться умным долбоёбом на ревью.
3. **В `main()` объявляются две переменные:**
    - `char ch;` — для хранения каждого введённого символа.
    - `int charcount = 0;` — счётчик для символов, которые не кавычки.
4. **Выводится подсказка юзеру:**  
    `Введите текст (закончите точкой '.'):`  
    — типа, «ебашь текст, мудила, но не забудь поставить точку, иначе хуй ты остановишься.»
5. **Запускается ебучий цикл `while`:**
    - Считывает один символ с помощью `getchar()`.
    - Если символ не равен `PERIOD` (`.`) И НЕ равен `EOF` (конец файла, типа `Ctrl+D` или `Ctrl+Z`), продолжаем крутиться в цикле.
6. **В теле цикла:**
    - Если введённый символ — **НЕ двойная кавычка** (`"`) и **НЕ одинарная кавычка** (`'`), тогда увеличиваем счётчик `charcount++`.
7. **Когда пользователь вбил `.` или нажал `EOF`, цикл нахуй ломается.**
8. **Печатается результат:**    
    `There are X characters other than quotes.`
    Где `X` — это количество всех введённых символов без учёта ёбаных кавычек.
9. **Программа заканчивается:**  
    `return 0;` — типо «Я всё, ёбушки-воробушки, я закончил».

 Вот более короткий и прямой разнос этого куска:
- **Чего код делает:**  
    Считает, сколько символов ты влепил без кавычек, пока не ткнул в точку.
- **Где ты идиот:**  
    Можно было бы ещё игнорировать пробелы, табуляции, новую строку и всякое другое говно, которое обычно юзеры любят оставлять.
- **Где норм:**  
    Проверка `ch != EOF` — красава, хоть чуть-чуть думал, не окончательно конченый.


```
#include <stdio.h>
#include <ctype.h>
#include <stdbool.h>
  
#define STOP '!'
  
int main(void) {
    char c;                      // прочитанный символ
    char prev = '\n';           // предыдущий прочитанный символ
    long n_chars = 0;           // количество символов
    int n_lines = 0;            // количество строк
    int n_words = 0;            // количество слов
    int p_lines = 0;            // количество неполных строк
    bool inword = false;        // true если символ находится внутри слова
    printf("Введите текст для анализа (! для завершения):\n");
    while ((c = getchar()) != STOP) {
        n_chars++;              // считаем символы
        if (c == '\n')         // считаем строки
            n_lines++;
        if (!isspace(c) && !inword) {
            inword = true;      // начало нового слова
            n_words++;          // считаем слова
        }
        if (isspace(c) && inword)
            inword = false;     // достигнут конец слова
        prev = c;              // сохранить значение символа
    }
    if (prev != '\n')
        p_lines = 1;
    printf("символов = %ld, слов = %d, строк = %d, ",
           n_chars, n_words, n_lines);
    printf("неполных строк = %d\n", p_lines);
    return 0;
}
```
Этот код — счётчик:
- сколько символов,
- сколько **слов**,
- сколько **строк**,
- и были ли **неполные строки**  
    во введённом пользователем тексте **до символа `!`**.


```
#include <stdio.h>
#include <ctype.h>
#include <stdbool.h>
```
- `stdio.h` — стандартное говно для `getchar`, `printf`.
- `ctype.h` — чтобы проверять пробелы через `isspace()`.
- `stdbool.h` — нормальные булевы значения `true` и `false`, а не это ваше постсоветское `int`-долбоебство.

```
#define STOP '!'
```
Макрос: Когда юзер набьёт `!`, мы остановим еблю ввода.

```
char c;
char prev = '\n';
long n_chars = 0;
int n_lines = 0;
int n_words = 0;
int p_lines = 0;
bool inword = false;
```
**Переменные:**
- `c` — текущий символ.
- `prev` — предыдущий символ (изначально `\n`, чтобы обработать начало правильно).
- `n_chars` — сколько **ВСЕГО символов** набил бедолага.
- `n_lines` — сколько **строк** он нахуярил (`\n`).
- `n_words` — сколько **слов** он выдавил из своего рта.
- `p_lines` — сколько **неполных строк** (если не кончали на `\n`).
- `inword` — флажок: ты **внутри слова** или опять в перерыве бухаешь?

```
while ((c = getchar()) != STOP) {
```
**Цикл:**  Жрём по одному символу, пока не вырвешься в `!`.

```
n_chars++;

```
**Увеличиваем количество символов** за каждый ввод.

```
if (c == '\n')
    n_lines++;

```
**Если `\n` — значит новая строка.**  
+1 к `n_lines`.

```
if (!isspace(c) && !inword) {
    inword = true;
    n_words++;
}
```
**Если символ НЕ пробельный (`!isspace(c)`) и ты ещё НЕ был в слове:**
- Значит это **начало нового слова**.
- Флажок `inword` становится `true`.
- Слово засчитывается.

```
if (isspace(c) && inword)
    inword = false;

```
**Если символ ПРОБЕЛ, и ты был в слове (`inword == true`):**
- Значит слово закончилось, и мы вываливаемся обратно в состояние "между словами".

```
prev = c;

```
**Запоминаем предыдущий символ**, чтобы потом понять, закончилась ли строка корректно или осталась не доебанная до конца.

```
if (prev != '\n')
    p_lines = 1;
```
**Если последнее было не `\n`, значит строка была неполной.**  
(То есть текст закончился где-то посреди строки без нажатия Enter.)

Что в итоге считается:

|Что|Как считается|
|---|---|
|Символы|Любой ввод, кроме `!`|
|Слова|Каждое начало набора НЕ пробельных символов|
|Строки|Каждый `\n`|
|Неполная строка|Если текст кончился не на `\n`|

## Условная операция ? :
```
условие ? значение_если_true : значение_если_false;
```

```
int a = 5, b = 10;
int max = (a > b) ? a : b;
```
Если `a > b`, то `max` будет `a`. Иначе — `b`. В данном случае `max` будет равен `10`. Всё просто как раз-два-три, не проси ещё рисунков, надеюсь, ты не совсем овощ.

## Когда его юзать?
Когда хочешь в одну строку принять решение. Не хочешь писать `if-else`, как примитивный дебил, вот и юзай `? :`.

## Когда **НЕ** стоит его использовать:
Когда у тебя здоровый кусок логики — **НЕ НАДО** пихать всё в тернарный оператор. Ты не гений, ты просто создаёшь говнокод.

```
#include <stdio.h>
  
#define SQUARE_FEET_PER_CAN 350 // площадь, которую может покрыть одна банка краски
  
int main() {
    int squareFeet; // площади в квадратных футах
    int paintCans; // количество банок краски
  
    printf("Введите количество квадратных футов, которые необходимо покрасить:\n");
    while (scanf("%d", &squareFeet) == 1)
    {
        paintCans = squareFeet / SQUARE_FEET_PER_CAN;  // целочисленное деление
        paintCans += ((squareFeet % SQUARE_FEET_PER_CAN == 0)) ? 0 : 1; // округление вверх
        printf("Для этого потребуется %d %s краски.\n", paintCans, //
            paintCans == 1 ? "банка" : "банки"); // "банка" или "банки"
        printf("Введите следующее значение (или q для завершения):\n");
    }
    return 0;
}
```

```
paintCans = squareFeet / SQUARE_FEET_PER_CAN;
```
Это — **грубый подсчёт**, сколько **полных банок** краски нужно. Если, например, у тебя:
```
squareFeet = 800
SQUARE_FEET_PER_CAN = 350
800 / 350 = 2 (целочисленное деление)
```
Ты получаешь **2 банки**, потому что третья типа "не влезла".
НО БЛЯДЬ — тебе же нужно **800 квадратов покрыть**, а **2 банки покрывают только 700**, значит тебе **не хватает** ещё **1 банки** даже если она будет использоваться не полностью:
```
paintCans += ((squareFeet % SQUARE_FEET_PER_CAN == 0)) ? 0 : 1;
```
- `%` — остаток от деления.
- Если **остатка нет** (=.=0), то всё красиво — ты всё покрыл, и тебе **не надо докидывать лишнюю банку**.
- Если **остаток есть**, то хоть и малюсенький кусок остался, но тебе **придётся брать ещё одну  банку**, потому что у тебя нет полу-банок.

- 800 % 350 = **100** → остался хвостик → нужна **ещё одна** банка.
- 700 % 350 = **0** → делится ровно → оставляем как есть.
Ты делишь, потом проверяешь, не осталась ли ещё недокрашенная сраная площадь. Если осталась — **впиндюриваешь ещё банку**, иначе — отдыхаешь как король.

Более чистый код:
```
#include <stdio.h>
  
#define SQUARE_FEET_PER_CAN 350 // площадь, которую может покрыть одна банка краски
  
int main() {
    int squareFeet; // площади в квадратных футах
    int paintCans; // количество банок краски
  
    printf("Введите количество квадратных футов, которые необходимо покрасить:\n");
    while (scanf("%d", &squareFeet) == 1)
    {
        paintCans = squareFeet / SQUARE_FEET_PER_CAN;  // целочисленное деление
        paintCans += ((squareFeet % SQUARE_FEET_PER_CAN == 0)) ? 0 : 1; // округление вверх
        printf("Для этого потребуется %d %s краски.\n", paintCans, //
            paintCans == 1 ? "банка" : "банки"); // "банка" или "банки"
        printf("Введите следующее значение (или q для завершения):\n");
    }
    return 0;
}
```
Вместо
```
 paintCans = squareFeet / SQUARE_FEET_PER_CAN;  // целочисленное деление
 paintCans += ((squareFeet % SQUARE_FEET_PER_CAN == 0)) ? 0 : 1; // округление вверх
```
Используется:
```
paintCans = (squareFeet + SQUARE_FEET_PER_CAN - 1) / SQUARE_FEET_PER_CAN;
```

## Continue - основная ин-фа выше
**пропускает текущую итерацию цикла** и **переходит к следующей**. То есть выполнение программы не прерывается, как с `break`, но **перепрыгивает** на следующую итерацию цикла.
Когда использовать:
- Когда нужно **пропустить текущую итерацию**, но не выходить из цикла полностью.
- Например, если ты хочешь игнорировать какие-то незначительные условия и продолжить проверку для других элементов.
```
#include <stdio.h>

int main() {
    for (int i = 0; i < 10; i++) {
        if (i == 5) {
            printf("Число 5 пропущено.\n");
            continue;  // Переходит к следующей итерации цикла, не выполняя код ниже
        }
        printf("i = %d\n", i);
    }

    printf("Цикл завершён.\n");
    return 0;
}
```
>i = 0
i = 1
i = 2
i = 3
i = 4
Число 5 пропущено.
i = 6
i = 7
i = 8
i = 9
Цикл завершён.

Как видишь, когда `i` было равно 5, программа **перешла к следующей итерации** цикла, пропустив печать этого числа.
## Break
полностью **выходит** из цикла (или из блока switch), не дожидаясь его завершения.

Когда использовать:
- Когда нужно **не ждать конца цикла**, а выйти раньше.
- Например, если ты нашёл нужный элемент или выполнил задачу — нет смысла продолжать цикл.
```
#include <stdio.h>

int main() {
    for (int i = 0; i < 10; i++) {
        if (i == 5) {
            printf("Нашёл число 5, выхожу из цикла.\n");
            break;  // Прерывает цикл, не давая ему пройти до конца
        }
        printf("i = %d\n", i);
    }

    printf("Цикл завершён.\n");
    return 0;
}
```
>i = 0
i = 1
i = 2
i = 3
i = 4
Нашёл число 5, выхожу из цикла.
Цикл завершён.

Как видишь, как только встретилось число `5`, цикл сразу прекратился, и больше не печатал значения. **`break`** прервал его досрочно.
![[Pasted image 20250501111958.png]]
На рис. 7.3 приведено сравнение операторов break и continue. Если оператор break находится внутри вложенных циклов, его действие распространяется только на самый внутренний цикл, в котором он содержится.

 Что делает код
1. Запрашивает **длину прямоугольника**.
2. Если ты ввёл число — просит ввести **ширину**.
3. Если и ширину ввёл как человек, считает и выводит **площадь**.
4. Затем всё повторяется.
5. Если на любом этапе ты ввёл **говно** (не число) — программа **вылазит из цикла и заканчивает**.
```
#include <stdio.h>
int main(void)
{
    double length, width;
    printf("Введите длину прямоугольника: ");
    while (scanf("%lf", &length) == 1)
    {
        printf("Длина = %0.2f:\n", length);
        printf("Введите ширину прямоугольника: ");
        if (scanf("%lf", &width) != 1)
            break;
        printf("Ширина = %0.2f:\n", width);
        printf("Площадь = %0.2f:\n", length * width);
        printf("Введите длину прямоугольника: ");
    }
    printf("Программа завершена.\n");
    return 0;
}
```
Цикл можно было бы реализовать следующим образом:
```
while (scanf("%f %f", &length, &width) == 2)
```
Однако применение оператора break существенно упрощает эхо-вывод вводимых значений.
Как и continue, не используйте оператор break, если это приводит к усложнению кода. Взгляните, например, на следующий цикл:
```
while((ch = getchar()) != '\n')
{
	if(ch=='\t')
		break;
	putchar(ch);
}
```
Логика программы станет яснее, если выполнять обе проверки в одном месте:
```
while ((ch = getchar()) != '\n' && ch !='\t')
	putchar(ch) ;
```
Оператор break является важным дополнением оператора switch, который будет рассматриваться следующим.
Оператор break передает управление оператору, который находится непосредс-твенно после цикла; в отличие от случая с continue внутри цикла for, пропускается обновляющая часть раздела управления цикла. Оператор break, помещенный внутрь вложенного цикла, приводит к выходу только из внутреннего цикла; для выхода из внешнего цикла необходим еще один break:

```
#include <stdio.h>
  
int main() {
    int p, q;
    scanf("%d", &p);
    while (p > 0) {
        printf("%d\n", p);
        scanf("%d", &q);
        while (q > 0) {
            printf("%d\n", p * q);
            if (q > 100)
                break;  // выход из внутреннего цикла
            scanf("%d", &q);
        }
        if (q > 100)
            break;  // выход из внешнего цикла
        scanf("%d", &p);
    }
    return 0;
}
```
  Данная программа реализует вложенные циклы для обработки пользовательского ввода.
  Алгоритм работы:
  1. Считывает число p
  2. Пока p > 0:
     - Выводит значение p
     - Считывает число q
     - Пока q > 0:
       * Выводит произведение p * q
       * Если q > 100, прерывает внутренний цикл
       * Считывает новое значение q
     - Если q > 100, прерывает внешний цикл
     - Считывает новое значение p
  Программа завершается когда:
  - Введено p <= 0, или
  - Введено q > 100, или
  - Введено q <= 0
  Входные данные:
  - Целые числа p и q, вводимые с клавиатуры
  Выходные данные:
  - Значение p при каждой итерации внешнего цикла
  - Произведение p * q при каждой итерации внутреннего цикла

### Разница между **`break`** и **`continue`**:
- **`break`** — полностью **выходит** из цикла, прекращает его выполнение.
- **`continue`** — **пропускает текущую итерацию** и переходит к следующей.
### Применение в реальной жизни:
- **`break`**: Если ты ищешь какую-то информацию в списке и нашёл её, нет смысла продолжать перебирать дальше, можно просто выйти.
- **`continue`**: Если ты обрабатываешь список, но хочешь пропустить только **неинтересные** или **неподходящие** элементы, продолжая работу с остальными.

```
#include <stdio.h>

int main() {
    int numbers[] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};

    for (int i = 0; i < 10; i++) {
        if (numbers[i] % 2 == 0) {
            continue;  // Пропускаем чётные числа
        }
        printf("%d - нечётное\n", numbers[i]);
    }

    return 0;
}
```
>1 - нечётное
3 - нечётное
5 - нечётное
7 - нечётное
9 - нечётное

Здесь мы **пропускаем чётные числа** с помощью `continue`, а для нечётных выводим сообщение.
- **`break`** — ты выходишь из цикла. **Завершаешь его.**
- **`continue`** — ты **перепрыгиваешь текущую итерацию**, но цикл продолжает работать.
## Выбор из множества вариантов: операторы switch и break
`switch` — это конструкция выбора, которая упрощает перечень условий вида `if (x == A) … else if (x == B) …`. С её помощью код становится чище и понятнее.
```
switch (выражение) {
    case константа1:
        инструкции1;
        break;
    case константа2:
        инструкции2;
        break;
    // можно сколько угодно case
    default:
        инструкции_по_умолчанию;
}
```
- **`выражение`** должно быть целочисленного типа (`int`, `char`, `enum`).
- Каждая **`константа`** проверяется как равенство `выражение == константа`.
- **`break`** завершает выполнение `switch` после совпавшего `case`. Без `break` будет «проваливание» (fall-through).
- **`default`** выполняется, если ни одно из значений не совпало. Этот блок необязателен, но рекомендуем его добавлять для надёжности.
Простой пример: дни недели
```
#include <stdio.h>

int main(void) {
    int day = 3;

    switch (day) {
        case 1:
            printf("Понедельник\n");
            break;
        case 2:
            printf("Вторник\n");
            break;
        case 3:
            printf("Среда\n");
            break;
        case 4:
            printf("Четверг\n");
            break;
        case 5:
            printf("Пятница\n");
            break;
        case 6:
            printf("Суббота\n");
            break;
        case 7:
            printf("Воскресенье\n");
            break;
        default:
            printf("Некорректный номер дня\n");
    }

    return 0;
}
```
Здесь переменная `day` равна `3`, поэтому вывод будет:
```
Среда
```

**Проваливание (fall-through)**  
Иногда нужно, чтобы несколько меток обрабатывались одной и той же секцией кода:
```
char ch = 'A';

switch (ch) {
    case 'a':
    case 'A':
        printf("Буква A (заглавная или строчная)\n");
        break;
    case 'b':
    case 'B':
        printf("Буква B\n");
        break;
    default:
        printf("Другая буква\n");
}
```
Здесь и для `'a'`, и для `'A'` выполнится один и тот же блок.

**Особенности и ограничения**
- В `case` можно использовать только **константы** (литералы или `enum`), а не переменные или диапазоны.
- Если забыть `break`, выполнение пойдёт дальше по коду до следующего `break` или конца `switch`.
- Порядок `case` не влияет на логику, но ради читаемости размещайте их в логическом порядке.

**Полезные советы**
- Всегда добавляйте `default` для отлавливания неожиданных значений.
- Избегайте слишком большого числа вариантов в одном `switch` — при необходимости разрабатывайте более гибкую структуру (например, использование массивов функций).
- Если у вас перечисление (`enum`), можно сделать `switch` по этому типу и покрыть все варианты — компилятор выдаст предупреждение, если не предусмотреть какой-то `case`.

```
#include <stdio.h>
  
char task[100];
  
void Tasks()
{
    printf("Здесь ты можешь создать свою задачу.\n");
    printf("Просто напиши её и потом выведи из меню!\n");
    fgets(task, sizeof(task), stdin);
}
  
int main()
{
    printf("Привет. Здесь ты можешь вывести свои задачи на этот день.\n");
    while(1){
    printf("Выбери одно из меню: 1 - Создать задачу; 2 - Вывести: ");
     int choice;
    if(scanf("%d", &choice) != 1){
        puts("Введи ебучее ЧИСЛО, а не хуйню.");
        while(getchar() != '\n');
        continue;  
    }
    while(getchar() != '\n');
    switch (choice)
    {
    case 1:
        Tasks();
        break;
    case 2:
        printf("Твоя задача(и) на сегодняшний день: %s\n", task);
        break;
    default:
        break;
    }
}
    return 0

}
```
>Привет. Здесь ты можешь вывести свои задачи на этот день.
Выбери одно из меню: 1 - Создать задачу; 2 - Вывести: 1
Здесь ты можешь создать свою задачу.
Просто напиши её и потом выведи из меню!
Насрать аллаху на голову
Выбери одно из меню: 1 - Создать задачу; 2 - Вывести: 2
Твоя задача(и) на сегодняшний день: Насрать аллаху на голову

**putc - тот же printf, но бедолага и онли вывести текст**
### fgets()
`fgets()` — одна из функций стандартной библиотеки C для безопасного чтения строк из файлов или стандартного ввода 
Она включена в заголовочный файл `<stdio.h>` и предназначена для предотвращения переполнения буфера, поскольку принимает параметр, ограничивающий число считываемых символов
```
char *fgets(char *str, int n, FILE *stream);
```
- **`str`**: указатель на массив `char`, куда будут записаны считанные символы 
- **`n`**: максимальное количество символов для чтения, включая место для завершающего нуля — фактически читается не более `n-1` символов 
- **`stream`**: указатель на `FILE`, с которого производится чтение (например, `stdin` или дескриптор открытого файла)
Возвращаемое значение
- При успешном чтении возвращается тот же указатель `str`, что позволяет легко проверить успех вызова 
- При ошибке или при достижении конца файла до чтения хотя бы одного символа возвращается `NULL` и содержимое `str` остаётся без изменений 
 
 Поведение и детали работы
1. **Остановка по символу `'\n'`**  
    При встрече символа новой строки `fgets()` включает его в буфер и завершает чтение, после чего записывает `'\0'` 
2. **Конец файла (EOF)**  
    Если до чтения любого символа встречается EOF, функция возвращает `NULL` и не изменяет буфер 
3. **Безопасность**  
    В отличие от устаревшей `gets()`, `fgets()` не позволяет прочитать более `n-1` символов, что защищает от переполнения буфера 
4. **Буферизация**  
    При чтении из потоков `stdin` или файлов `fgets()` может блокироваться до тех пор, пока не наберётся требуемое число символов, не встретится `'\n'` или не наступит EOF 

```
#include <stdio.h>

int main(void) {
    char buffer[100];
    printf("Введите строку: ");
    if (fgets(buffer, sizeof(buffer), stdin) != NULL) {
        printf("Вы ввели: %s", buffer);
    } else {
        perror("Ошибка чтения");
    }
    return 0;
}
```
В этом примере функция `fgets()` безопасно прочитает до 99 символов (98 символов плюс `'\n'` и `'\0'`) из стандартного ввода

 **`fgets(buffer, sizeof(buffer), stdin)`**
- `fgets()` — это функция, которая читает строку из потока (в данном случае `stdin`, то есть стандартный ввод) и записывает её в массив `buffer`.
- **`buffer`** — это массив, в который будет записан прочитанный текст. Как ты заметил, это `char *`, который указывает на первый элемент массива.
- **`sizeof(buffer)`** — это оператор, который возвращает размер самого массива `buffer`.
    - Это важно, потому что функция `fgets()` ожидает второй параметр как максимальный размер буфера (включая место для завершающего нулевого символа).
    - Например, если у тебя есть `char buffer[100];`, то `sizeof(buffer)` вернёт 100, что и является максимальной длиной строки, которую может считать `fgets()`.


 **Общие ошибки**
- **Неправильный размер буфера**  
    Если `n` больше размера массива `str`, может произойти выход за границы памяти 
- **Остаточные символы в потоке**  
    Если строка длиннее `n-1` символов, в потоке останутся непрочитанные символы, которые могут повлиять на последующие вызовы ввода
- **Проверка возвращаемого значения**  
    Нужно всегда проверять, не вернула ли `fgets()` `NULL`, иначе дальнейшая работа с буфером может привести к неопределённому поведению 

 Когда **нужно** использовать `fgets()`
- **Чтение строк** из текстового файла или стандартного ввода с ограничением длины.
- Когда хочется **защититься от переполнения буфера** (в отличие от устаревшей `gets()`).
- Нужно сохранить символ `'\n'` (он считывается и позволяет понять, что строка была «короткой»).
 Когда **не стоит** использовать `fgets()`
- Для **побайтового** или **бинарного** чтения (лучше `fread()`).
- Если вам нужна **динамически растущая** строка неизвестной заранее длины (лучше `getline()` или ваша реализация на `malloc/realloc`).
- Когда нужно прочитать **отдельные символы** без буферизации (лучше `getchar()` или `fgetc()`).

`fgets()` для ввода возраста, имени и других строковых данных — это вполне разумное решение, особенно если нужно безопасно считывать данные, избегая переполнения буфера, как это может случиться при использовании `scanf()`.
Однако, стоит учитывать некоторые моменты, например, для ввода числовых значений нужно будет дополнительно конвертировать строку в число, а для ввода имени или других строковых данных — обрабатывать лишний символ новой строки `'\n'`, который остаётся после ввода.

Ввод имени с использованием `fgets()`
```
#include <stdio.h>

int main() {
    char name[50]; // Массив для имени (максимум 49 символов)

    printf("Введите ваше имя: ");
    if (fgets(name, sizeof(name), stdin) != NULL) {
        // Удаляем символ новой строки, если он был считан
        size_t len = strlen(name);
        if (len > 0 && name[len - 1] == '\n') {
            name[len - 1] = '\0';  // Заменяем символ новой строки на '\0'
        }
        printf("Ваше имя: %s\n", name);
    } else {
        printf("Ошибка при вводе имени\n");
    }

    return 0;
}
```
Почему это хорошая идея:
- **Безопасность**: `fgets()` предотвращает переполнение буфера, что может произойти при использовании `scanf()` без указания размера буфера. Например, при вводе очень длинного имени через `scanf("%s", name)` в случае слишком длинной строки программа может выйти из строя.
- **Простота обработки**: Символ новой строки `'\n'`, оставшийся после ввода, можно легко удалить, заменив его на нулевой символ `'\0'`.

Ввод возраста (числовое значение) с использованием `fgets()`
Когда тебе нужно считать числовое значение, например, возраст, можно использовать `fgets()`, а затем преобразовать строку в целое число с помощью функции `atoi()` или `strtol()`.
```
#include <stdio.h>
#include <stdlib.h>

int main() {
    char age_str[10]; // Буфер для ввода возраста
    int age;

    printf("Введите ваш возраст: ");
    if (fgets(age_str, sizeof(age_str), stdin) != NULL) {
        // Преобразуем строку в число
        age = atoi(age_str);

        // Проверяем, что возраст не является некорректным
        if (age > 0) {
            printf("Ваш возраст: %d\n", age);
        } else {
            printf("Некорректный возраст\n");
        }
    } else {
        printf("Ошибка при вводе возраста\n");
    }
    return 0;
}
```
 Почему это хорошая идея:
1. **Безопасность**: Использование `fgets()` гарантирует, что ты не прочитаешь больше символов, чем размер буфера. Это предотвращает переполнение буфера.
2. **Обработка некорректного ввода**: Ты можешь легко обрабатывать некорректный ввод (например, строку, а не число), если после преобразования ты проверишь, является ли результат конвертации валидным.
Важные моменты при использовании `fgets()` для чисел:
- Если ты хочешь проверить, является ли строка корректным числовым значением, лучше использовать `strtol()`, так как она позволяет точно проверить, было ли успешное преобразование
```
#include <stdio.h>
#include <stdlib.h>

int main() {
    char age_str[10];
    char *endptr;
    long age;

    printf("Введите ваш возраст: ");
    if (fgets(age_str, sizeof(age_str), stdin) != NULL) {
        age = strtol(age_str, &endptr, 10);  // Преобразуем в число

        // Проверяем, не было ли ошибки
        if (*endptr == '\0' || *endptr == '\n') {
            printf("Ваш возраст: %ld\n", age);
        } else {
            printf("Некорректный ввод возраста\n");
        }
    } else {
        printf("Ошибка при вводе возраста\n");
    }

    return 0;
}

```
Здесь `strtol()` позволяет не только преобразовать строку в число, но и проверяет, есть ли остаточные символы после числа, которые могут свидетельствовать о некорректном вводе.

Резюме:
Использование `fgets()` для ввода строк (например, имени) и чисел (например, возраста) — это **безопасный** и **гибкий** способ обработки ввода, который помогает избежать переполнения буфера и легко обрабатывает ошибочные или некорректные данные.

#### **`atoi()` (ASCII to Integer)**
**`atoi()`** — это функция, которая преобразует строку в целое число типа `int`. Она выполняет простое преобразование, но не предоставляет подробной информации о возможных ошибках при преобразовании.
```
#include <stdio.h>
#include <stdlib.h>

int main() {
    const char *str = "123";
    int num = atoi(str);
    printf("Число: %d\n", num);  // Вывод: Число: 123
    return 0;
}
```
- Если строка содержит корректное число, `atoi()` вернёт это число.
- Если строка не является корректным числом (например, если строка не начинается с цифры), результат будет `0`. Это может быть путаницей, потому что `0` также может быть корректным числом, если строка действительно представляет `0`.
**Недостатки `atoi()`**:
- **Не обрабатывает ошибки**: Если строка не является числом, результат будет просто `0`, что может привести к недоразумениям.
- **Не сообщает, сколько символов было успешно обработано**.
#### **`strtol()` (String to Long)**
**`strtol()`** — это более мощная и гибкая функция, которая преобразует строку в целое число типа `long`. В отличие от `atoi()`, она позволяет получить дополнительные данные о процессе преобразования, например, где именно строка заканчивается и что именно было интерпретировано как число.
```
long strtol(const char *str, char **endptr, int base);
```
- **`str`** — это строка, которую мы хотим преобразовать в число.
- **`endptr`** — это указатель на указатель, который будет указывать на первый символ, который не был обработан как часть числа.
- **`base`** — основание системы счисления (например, 10 для десятичной системы, 16 для шестнадцатиричной и т.д.).

```
#include <stdio.h>
#include <stdlib.h>

int main() {
    const char *str = "123abc";
    char *endptr;
    long num = strtol(str, &endptr, 10);  // Преобразуем в десятичное число

    printf("Число: %ld\n", num);  // Вывод: Число: 123
    printf("Остаток строки: %s\n", endptr);  // Вывод: Остаток строки: abc

    return 0;
}
```
- В этом примере `strtol()` преобразует "123" в число, а оставшуюся часть строки ("abc") записывает в `endptr`.
- Это полезно, когда ты хочешь проверить, были ли какие-то символы после числа или если преобразование не удалось на каком-то этапе.
**Преимущества `strtol()`**:
- **Обработка ошибок**: Ты можешь узнать, где строка прекратила преобразовываться, и если там остались дополнительные символы, это будет видно через `endptr`.
- **Гибкость**: `strtol()` поддерживает разные системы счисления (десятичная, шестнадцатиричная и т.д.) через параметр `base`.
### Что значит `*endptr` и `&endptr`?
Теперь давай разберемся с тем, что означают `*endptr` и `&endptr` в контексте примера с `strtol()`.
#### **`*endptr`**:
- Это указатель на символ (тип `char*`), который будет указывать на первый символ, который не был обработан как часть числа. После вызова `strtol()`, если в строке есть символы, которые не могут быть интерпретированы как цифры (например, буквы после числа), то указатель `endptr` будет указывать на эти символы.
#### **`&endptr`**:
- Это **адрес** переменной `endptr`. Функция `strtol()` изменяет значение `endptr`, присваивая ему адрес первого нецифрового символа после числа в строке. Мы передаем в `strtol()` не сам указатель `endptr`, а его адрес, чтобы функция могла записать результат в эту переменную.
```
const char *str = "123abc";
char *endptr; // Объявляем указатель на символ
long num = strtol(str, &endptr, 10);  // Преобразуем строку в число

printf("Число: %ld\n", num);  // Вывод: Число: 123
printf("Остаток строки: %s\n", endptr);  // Вывод: Остаток строки: abc
```

- **`strtol(str, &endptr, 10)`**:
    - Функция пытается преобразовать строку `str` в число в десятичной системе счисления (base = 10).
    - При этом:
        - Первые символы в строке (`123`) успешно преобразуются в число, и это число сохраняется в переменной `num`.
        - Указатель `endptr` будет указывать на символ, который сразу идет после числа, то есть на строку "abc".
- **`*endptr`**:
    - **`endptr`** — это указатель, который после выполнения функции указывает на начало строки "abc". Когда мы выводим `*endptr`, мы получаем строку "abc", начиная с первого символа, который не является частью числа.
 Что важно:
- **`endptr`** помогает понять, что произошло с остатком строки после числового преобразования. Если ты видишь, что в `endptr` осталась строка, которую ты не хотел, это может сигнализировать о проблемах с вводом.
 
 Пример с обработкой ошибок:
Допустим, мы хотим обработать ошибки ввода и сообщить пользователю, если введенная строка не является валидным числом:
```
#include <stdio.h>
#include <stdlib.h>

int main() {
    const char *str = "123abc";
    char *endptr;
    long num = strtol(str, &endptr, 10);

    if (*endptr != '\0') {
        printf("Ошибка: остаток строки после числа: %s\n", endptr);
    } else {
        printf("Число: %ld\n", num);
    }

    return 0;
}
```

### Что означает `char *str = "123abc";`?
- **`char *str`** — это указатель на символ (или строку). В языке C строки хранятся как массивы символов, заканчивающиеся нулевым символом (`'\0'`).
- **`"123abc"`** — это строковый литерал. Строковый литерал всегда создается как массив символов, и в конце этого массива будет стоять нулевой символ (`'\0'`), который указывает на конец строки.
- **`char *str = "123abc";`** — это означает, что переменная `str` будет указателем на первый символ строки `"123abc"`.
### Ответ на вопрос: "Обязательно ли писать `*` в `char *str = "123abc";`?"
Да, нужно писать `*`, потому что это указатель на строку. В языке C строка представлена как массив символов, и указатель на первый символ этого массива называется строковым указателем.
#### Почему именно `char *`?
1. **Массивы и указатели**: Строки в C — это массивы символов, и когда ты передаешь строку в функцию или присваиваешь ее переменной, ты работаешь с указателем на первый элемент этого массива. То есть, `char *str` — это не сам массив, а указатель на его первый элемент.

**Пример с массивом**:
```
char str[] = "123abc";
```
В этом случае `str` — это массив символов, и его элементы можно изменять. Однако строковый литерал, например `"123abc"`, фактически является константным массивом символов, и изменение содержимого этого массива обычно вызывает ошибку.
**Пример с указателем**:
```
char *str = "123abc";
```
Здесь `str` — это указатель на строковый литерал. Указатель указывает на память, где хранится строка. Обычно литералы строк в C размещаются в постоянной (read-only) памяти, и попытка изменить содержимое строки (например, `str[0] = 'A';`) приведет к ошибке выполнения.
 
 Разница между массивом и указателем
```
char str[] = "123abc";
```
Это означает, что у тебя есть массив из символов. Ты можешь изменять каждый символ в этом массиве (например, `str[0] = 'A';`).
```
char *str = "123abc";
```
Это указатель на строку. Ты не можешь изменять содержимое строки, потому что строковый литерал обычно размещается в защищенной области памяти. Если попытаться изменить строку, будет ошибка.


**прототип функции**.

## Буфер ввода в Си
		Что такое **буфер ввода** в `C`?
Когда ты вводишь что-то с клавиатуры, это **не сразу** поступает в переменные в твоём коде.  
Оно сначала **отправляется в буфер** — это как такая временная срань, куда система копит то, что ты ввёл, **пока не нажмёшь `Enter`**.
> Это делает твой ввод **строковым** по сути, даже если ты считываешь по символам.

```
int x;
scanf("%d", &x);
```
Ты вводишь:
```
123abc\n
```
- `scanf("%d", &x)` сожрёт только `123`
- Остальное (`abc\n`) — **останется в ебаном stdin-буфере**
- При следующем `scanf`, `getchar`, `fgets`, `gets`, `scanf("%s")` и т.д. — ты получишь **весь этот мусор**

 Что делает `getchar()`?
Он **берёт один символ из буфера**.  
Если буфер **пустой**, он **ждёт, пока ты что-то введёшь** и нажмёшь `Enter`.
Если ты написал:
```
int ch = getchar();
```
То:
- Если буфер пуст → ждёт ввода
- Если буфер полон (`abc\n`) → берёт **`a`**, остальное остаётся
Зачем делать это?
```
while ((ch = getchar()) != '\n' && ch != EOF);
```
Это **вычищает весь мусор**, оставшийся после `scanf`.  
Особенно полезно, когда после `scanf("%d", &x)` идёт `fgets()`, а ты не хочешь получить пустую строку.

**Как это устроено на уровне ОС?**
Твой stdin — это файловый дескриптор (обычно 0), который обёрнут в буферизированный FILE* поток (stdio.h).
Когда ты вызываешь scanf, getchar, fgets и т.п. — они не напрямую читают из клавиатуры.
Они читают в буфер, размером 4-8КБ, в зависимости от реализации
Потом уже оттуда возвращают значения твоим жалким переменным>)

Типы буферизации:

|Тип буфера|Что это такое|
|---|---|
|**Полная**|Читает и пишет большими кусками (например, файл)|
|**Построчная**|Ждёт `\n`, затем передаёт (например, терминал)|
|**Без буфера**|Чтение/запись сразу (например, `stderr`)|

Ты вводишь:
```
42 Hello World\n
```
```
int x;
char buf[100];
scanf("%d", &x); // забирает 42
fgets(buf, 100, stdin); // забирает " Hello World\n"
```
Если ты **не сделаешь очистку буфера**, а просто тупо вызовешь `fgets()` после `scanf()` — ты получишь **всю поебень из stdin**, в том числе `\n`.

Как не быть долбоёбом:
После `scanf` всегда **очищай stdin**:
```
while ((ch = getchar()) != '\n' && ch != EOF);
```
Или **не миксуй `scanf` и `fgets`** — юзай только `fgets` и потом `sscanf`.

## Sscanf
Это функция, которая **не лезет в stdin**, как `scanf`, а **парсит строку**, которую ты сам ей суёшь.

## Прототип:
```
int sscanf(const char *str, const char *format, ...);
```
- `str` — строка, которую ты уже **где-то получил**, например `fgets()`-ом
- `format` — такой же, как у `scanf`
- Остальное — указатели на переменные

```
char input[100];
int number;

fgets(input, sizeof(input), stdin);        // читаем всю строку
sscanf(input, "%d", &number);              // вытаскиваем число
```
📌 `scanf("%d", &number)` ломается, если осталась хуита в буфере  
📌 А `sscanf()` работает **с уже очищенной строкой**, без лишнего мусора

```
char input[100];
int a, b;
fgets(input, sizeof(input), stdin);
sscanf(input, "%d %d", &a, &b);
```
Ты вводишь:
```
12 34
```
✅ `a = 12`, `b = 34`

А если ты вводишь что-то типа:
```
12 лягушка
```
— тогда `a = 12`, `b` вообще **не трогается**  
Ты можешь проверить, **сколько значений успешно считано**:
```
int count = sscanf(input, "%d %d", &a, &b);
if (count == 2)
    puts("Оба числа прочитаны");
else
    puts("Какая-то хуйня в строке");
```

## 💀 Почему `scanf` — мусор?
- Жрёт буфер ввода, ломает `fgets`
- Плохо обрабатывает ошибки
- Невозможно нормально очистить `stdin` в кроссплатформенной манере
- **Микс `scanf` и `fgets` — боль**

## ✅ Почему `sscanf` — топ:
- Ты сам контролируешь ввод (`fgets`)
- Нет проблем с буфером
- Гораздо легче ловить ошибки
- Работает с любой строкой, не только из `stdin`

## goto
https://chatgpt.com/share/681a3095-ec90-8008-8f8c-d32c976aa766
Для пидорасов, короче.


# Глава 8: Символьный ввод-вывод и проверка достоверности ввода


















